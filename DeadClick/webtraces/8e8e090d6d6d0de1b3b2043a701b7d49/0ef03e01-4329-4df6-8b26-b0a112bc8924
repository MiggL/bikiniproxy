/**
 * Created by Anas Imam on 4/18/2016.
 */
var MODSParser = (function () {
    /**
     * Prepares MODSParser for conversion
     * @param eid
     * @param mods
     */
    function MODSParser(eid, mods) {
        this.eid = eid;
        this.mods = mods;
    }
    /**
     * converts provided mods(json object) from MODS to IPublication
     * @returns {IPublication}
     */
    MODSParser.prototype.convert = function () {
        if (this.publication == null) {
            var eid = this.eid;
            var mods = this.mods;
            var mobj = {
                id: eid,
                type: this.findType(mods),
                title: this.xtitle(mods.titleInfo),
                year: null,
                ext: {}
            };
            var setp = function (prop, val) {
                if (val != null)
                    mobj[prop] = val;
            };
            try {
                setp('author', this.parseNames(mods, ['author', 'aut']));
                setp('editor', this.parseNames(mods, ['editor', 'edt']));
                setp('composer', this.parseNames(mods, ['composer']));
                setp('interviewer', this.parseNames(mods, ['interviewer']));
                setp('recipient', this.parseNames(mods, ['recipient']));
                setp('translator', this.parseNames(mods, ['translator', 'trl']));
                setp('contributor', this.parseNames(mods, ['contributor', 'ctb']));
            }
            catch (e) {
                console.error(e);
            }
            var oi = mods.originInfo ? mods.originInfo[0] : {};
            var ri = mods.relatedItem ? mods.relatedItem : {};
            var rioi = ri.originInfo ? ri.originInfo : {};
            var diroot = mods.dateIssued ? mods.dateIssued : {};
            try {
                var ritems = mods.relatedItem;
                if (ritems) {
                    for (var prop in ritems) {
                        var ri = CwZ(ritems)[0];
                        if (ri.type && ri.type == 'host') {
                            //setp('original-publisher', this.parseNames(ri, 'publisher'));
                            //setp('original-author', this.parseNames(ri, 'author'));
                            setp('container-author', this.parseNames(ri, ['author']));
                        }
                        else if (ri.$ && ri.$.type == 'series') {
                            setp('collection-editor', this.parseNames(ri, ['editor']));
                        }
                        if (ri.titleInfo) {
                            setp('container-title', this.xtitle(ri.titleInfo));
                            setp('collection-title', this.text(ri.titleInfo[0].partNumber));
                        }
                    }
                }
            }
            catch (ex) {
                console.warn('MODS.2 ..', ex.message, ex.source, eid);
            }
            try {
                var di = oi.dateIssued || rioi.dateIssued || diroot;
                var dt = this.xdate(this.text(di));
                if (dt) {
                    setp('issued', dt);
                    setp('year', dt.year);
                }
            }
            catch (ex) {
                console.warn('MODS.3 ..', ex.message, ex.source, eid);
            }
            try {
                setp('publisher-place', this.xplace(oi) || this.xplace(rioi));
                var publisher = this.text(oi.publisher || rioi.publisher);
                if (!publisher) {
                    var dg = this.parseNames(mods, ['degree grantor']);
                    if (dg && dg[0])
                        publisher = dg[0].literal;
                }
                setp('publisher', publisher);
            }
            catch (ex) {
                console.warn('MODS.4 ..', ex.message, ex.source, eid, mobj);
            }
            try {
                var part = ri.part || mods.part;
                if (part) {
                    var det = part[0].detail; // issue, volume
                    if (det && det[0].$) {
                        setp(det[0].$.type, this.text(det[0].number));
                    }
                    if (part[0].extent)
                        setp('page', this.xpage(part[0].extent[0]));
                }
                this.identify(mobj, ri.identifier);
                this.identify(mobj, mods.identifier);
                var desc = this.text(mods["abstract"]);
                if (desc) {
                    mobj.ext.description = desc;
                }
                var kw = [];
                var subs = mods.subject || [];
                for (var x = 0; x < subs.length; x++) {
                    var txt = this.text(subs[x].topic);
                    if (!this.containsObj(kw, txt))
                        kw.push(txt);
                }
                if (kw.length > 1) {
                    mobj.ext.keywords = kw.join('; ');
                }
            }
            catch (ex) {
                console.warn('MODS.5 ..', ex.message, ex.source, eid);
            }
            try {
                // @displayLabel == "Active Site"
                if (mods.location) {
                    var urls = mods.location[0].url;
                    var url = '';
                    if (urls && urls.length)
                    //URL is a string type in csl json, taking the only first URL
                        url = this.text(mods.location[0].url[0]);
                    else
                        url = this.text(mods.location[0].url);
                    setp('URL', url);
                    var da = oi.dateAccessed || oi.dateIssued || rioi.dateIssued;
                    var dt = this.xdate(this.text(da));
                    setp('accessed', dt);
                    mobj.ext.url = [];
                    for (var i = 0; i < urls.length; i++) {
                        var u = urls[i];
                        var murl = {};
                        murl.url = this.text(u);
                        for (var v in u.$) {
                            murl[v] = u.$[v];
                        }
                        mobj.ext.url.push(murl);
                    }
                }
            }
            catch (ex) {
                console.warn('MODS.6 ..', ex.message, ex.source, eid);
            }
            try {
                var notes = [];
                if (mods.note) {
                    var len = mods.note.length;
                    for (var i = 0; i < len; i++) {
                        notes.push(this.text(mods.note[i]));
                    }
                    mobj.note = notes[0];
                    mobj.notes = notes;
                }
            }
            catch (ex) {
                console.warn('MODS.7 (notes)..', ex.message, ex.source, eid);
            }
            this.publication = mobj;
        }
        return this.publication;
    };
    MODSParser.prototype.findType = function (mods) {
        var htype = null;
        var type = null;
        var ctype = null;
        var genres = mods.genre || [];
        for (var i = 0; i < genres.length; i++) {
            var g = genres[i];
            if (g.$ && g.$.authority == 'colwiz') {
                ctype = this.text(g);
                break;
            }
            else {
                type = this.text(g);
            }
        }
        if (ctype) {
            type = ctype;
        }
        if (!type) {
            for (var i = 0; i < genres.length; i++)
                type = genres[i];
            genres = mods.relatedItem ? (mods.relatedItem[0].genre || []) : [];
            for (var i = 0; i < genres.length; i++)
                htype = genres[i];
        }
        return PubType.toCSLType(type, htype);
    };
    MODSParser.prototype.text = function (e) {
        if (e == null)
            return null;
        var r = e[0];
        if (r) {
            if (r._)
                return r._;
            if (r.nodeValue)
                return r.nodeValue;
        }
        if (e._)
            return e._;
        if (e.nodeValue)
            return e.nodeValue;
        return e.toString();
    };
    MODSParser.prototype.xplace = function (oinfo) {
        if (!oinfo)
            return null;
        var place = oinfo.place;
        if (!place)
            return null;
        for (var i = 0; i < place.length; i++) {
            var pt = place[i].placeTerm;
            if (pt[0])
                pt = pt[0];
            if (pt.$ && pt.$.type == 'text') {
                return this.text(pt);
            }
        }
        return place && place[0] ? this.text(place[0].placeTerm) : null;
    };
    MODSParser.prototype.xdate = function (strdt) {
        try {
            if (!strdt)
                return null;
            var dt = new Date(strdt);
            var dta = {
                year: dt.getFullYear()
            };
            if (dta.year && strdt.length > 6) {
                dta.month = (dt.getMonth() + 1);
                dta.day = dt.getDate();
            }
            return dta;
        }
        catch (ex) {
            return null;
        }
    };
    MODSParser.prototype.xtitle = function (xti) {
        var xt = xti;
        if (xti.length) {
            xt = xti[0];
            for (var i = 0; i < xti.length; i++) {
                var t = xti[i];
                if (t.$ && t.$.type == 'abbreviated')
                    continue;
                xt = t;
            }
        }
        var title = this.text(xt.title);
        if (!title)
            return null;
        var stitle = this.text(xt.subTitle);
        if (stitle && stitle.trim().length > 1) {
            title += ": " + stitle.trim();
        }
        title = title.trim();
        var nonSort = this.text(xt.nonSort);
        if (nonSort && nonSort.length > 0) {
            title = nonSort + " " + title;
        }
        // removing TexChars .. TODO: handle them better
        title = title.replace(/\{|\}|\\|\$/g, '');
        //title = title.replace(/\{|\}|\[|\]|\$/g, ' ').replace(/\s+/g,' ');
        // subscript superscript support in plugin
        title = title.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/<(\/)?(bold)>/ig, "<$1b>").
            replace(/<(\/)?(italic)>/ig, "<$1i>").replace(/<(\/)?(xref)>/ig, "<$1sup>");
        return title;
    };
    MODSParser.prototype.identify = function (obj, xids) {
        if (xids == null)
            return false;
        obj.ext.idents = obj.ext.idents || {};
        for (var i = 0; i < xids.length; i++) {
            try {
                var xid = xids[i];
                var xt = xid.$.type;
                var xv = this.text(xid).replace("&amp;", "&");
                if (xv == '[object Object]')
                    xv = '';
                obj.ext.idents[xt] = xv;
                //console.info(xid);
                switch (xt) {
                    case "doi":
                        obj.DOI = xv;
                        break;
                    case "isbn":
                        obj.ISBN = xv;
                        break;
                    case "issn":
                        obj.ISSN = xv;
                        break;
                    case "citekey":
                        obj.citekey = xv;
                        break;
                }
            }
            catch (ex) {
                console.error(ex);
            }
        }
    };
    MODSParser.prototype.parseNames = function (m, type) {
        var arr = [];
        var nms = m.name;
        if (!nms)
            return null;
        for (var j = 0; j < nms.length; j++) {
            var roleTerm;
            if (nms[j].role)
                roleTerm = this.text(nms[j].role.roleTerm);
            if (!roleTerm || roleTerm == '[object Object]')
                roleTerm = 'author';
            if (Array.isArray(type)) {
                var bool = false;
                type.forEach(function (elem) {
                    bool = bool || (roleTerm == elem);
                });
                if (!bool)
                    continue;
            }
            else {
                if (roleTerm != type) {
                    continue;
                }
            }
            var nps = nms[j].namePart;
            var family = null;
            var literal = null;
            var given = "";
            for (var k = 0; k < nps.length; k++) {
                var np = nps[k];
                var npt = np.type ? np.type : null;
                if (npt == 'family') {
                    family = this.text(np);
                }
                else if (npt == 'given') {
                    if (given != "")
                        given += " ";
                    var gn = this.text(np);
                    if (gn.length == 1)
                        gn += ".";
                    given += gn;
                }
                else {
                    literal = this.text(np);
                }
            }
            if (family && family.toLowerCase() != 'others') {
                if (given.length > 0) {
                    arr.push({
                        "family": family.trim(),
                        "given": given.trim()
                    });
                }
                else {
                    arr.push({
                        "literal": family.trim(),
                        "parse-names": true
                    });
                }
            }
            else if (literal) {
                arr.push({
                    "literal": literal.trim(),
                    "parse-names": true
                });
            }
        }
        if (arr.length == 0)
            return null;
        /*if (obj) {
         for (var n = 0; n < arr.length; n++) {
         var c = arr[n];
         var cn = c.literal ? c.literal : c.family + ' ' + c.given;
         this.creators.push(cn);
         }
         }*/
        return arr;
    };
    MODSParser.prototype.xpage = function (pext) {
        if (pext && pext.$) {
            var unit = pext.$.unit;
            if (unit && unit.substr(0, 4) == "page") {
                var ps = this.text(pext.start);
                if (ps) {
                    var pe = this.text(pext.end);
                    if (pe)
                        ps += "-" + pe;
                    return ps;
                }
                else {
                    return this.text(pext.list);
                }
            }
        }
        return null;
    };
    MODSParser.prototype.containsObj = function (array, obj) {
        var len = array.length;
        for (var i = 0; i < len; i++) {
            if (array[i] === obj)
                return true;
        }
        return false;
    };
    return MODSParser;
})();






/*	This work is licensed under Creative Commons GNU LGPL License.

 License: http://creativecommons.org/licenses/LGPL/2.1/
 Version: 0.9
 Author:  Stefan Goessner/2006
 Web:     http://goessner.net/
 */
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

function X2JS(config) {
    'use strict';

    var VERSION = "1.1.5";

    config = config || {};
    initConfigDefaults();
    initRequiredPolyfills();

    function initConfigDefaults() {
        if(config.escapeMode === undefined) {
            config.escapeMode = true;
        }
        config.attributePrefix = config.attributePrefix || "_";
        config.arrayAccessForm = config.arrayAccessForm || "none";
        config.emptyNodeForm = config.emptyNodeForm || "text";
        if(config.enableToStringFunc === undefined) {
            config.enableToStringFunc = true;
        }
        config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];
        if(config.skipEmptyTextNodesForObj === undefined) {
            config.skipEmptyTextNodesForObj = true;
        }
        if(config.stripWhitespaces === undefined) {
            config.stripWhitespaces = true;
        }
        config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
    }

    var DOMNodeTypes = {
        ELEMENT_NODE 	   : 1,
        TEXT_NODE    	   : 3,
        CDATA_SECTION_NODE : 4,
        COMMENT_NODE	   : 8,
        DOCUMENT_NODE 	   : 9
    };

    function initRequiredPolyfills() {
        function pad(number) {
            var r = String(number);
            if ( r.length === 1 ) {
                r = '0' + r;
            }
            return r;
        }
        // Hello IE8-
        if(typeof String.prototype.trim !== 'function') {
            String.prototype.trim = function() {
                return this.replace(/^\s+|^\n+|(\s|\n)+$/g, '');
            }
        }
        if(typeof Date.prototype.toISOString !== 'function') {
            // Implementation from http://stackoverflow.com/questions/2573521/how-do-i-output-an-iso-8601-formatted-string-in-javascript
            Date.prototype.toISOString = function() {
                return this.getUTCFullYear()
                    + '-' + pad( this.getUTCMonth() + 1 )
                    + '-' + pad( this.getUTCDate() )
                    + 'T' + pad( this.getUTCHours() )
                    + ':' + pad( this.getUTCMinutes() )
                    + ':' + pad( this.getUTCSeconds() )
                    + '.' + String( (this.getUTCMilliseconds()/1000).toFixed(3) ).slice( 2, 5 )
                    + 'Z';
            };
        }
    }

    function getNodeLocalName( node ) {
        var nodeLocalName = node.localName;
        if(nodeLocalName == null) // Yeah, this is IE!!
            nodeLocalName = node.baseName;
        if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
            nodeLocalName = node.nodeName;
        return nodeLocalName;
    }

    function getNodePrefix(node) {
        return node.prefix;
    }

    function escapeXmlChars(str) {
        if(typeof(str) == "string")
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
        else
            return str;
    }

    function unescapeXmlChars(str) {
        return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/');
    }

    function toArrayAccessForm(obj, childName, path) {
        switch(config.arrayAccessForm) {
            case "property":
                if(!(obj[childName] instanceof Array))
                    obj[childName+"_asArray"] = [obj[childName]];
                else
                    obj[childName+"_asArray"] = obj[childName];
                break;
            /*case "none":
             break;*/
        }

        if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
            var idx = 0;
            for(; idx < config.arrayAccessFormPaths.length; idx++) {
                var arrayPath = config.arrayAccessFormPaths[idx];
                if( typeof arrayPath === "string" ) {
                    if(arrayPath == path)
                        break;
                }
                else
                if( arrayPath instanceof RegExp) {
                    if(arrayPath.test(path))
                        break;
                }
                else
                if( typeof arrayPath === "function") {
                    if(arrayPath(obj, childName, path))
                        break;
                }
            }
            if(idx!=config.arrayAccessFormPaths.length) {
                obj[childName] = [obj[childName]];
            }
        }
    }

    function fromXmlDateTime(prop) {
        // Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
        // Improved to support full spec and optional parts
        var bits = prop.split(/[-T:+Z]/g);

        var d = new Date(bits[0], bits[1]-1, bits[2]);
        var secondBits = bits[5].split("\.");
        d.setHours(bits[3], bits[4], secondBits[0]);
        if(secondBits.length>1)
            d.setMilliseconds(secondBits[1]);

        // Get supplied time zone offset in minutes
        if(bits[6] && bits[7]) {
            var offsetMinutes = bits[6] * 60 + Number(bits[7]);
            var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';

            // Apply the sign
            offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);

            // Apply offset and local timezone
            d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
        }
        else
        if(prop.indexOf("Z", prop.length - 1) !== -1) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
        }

        // d is now a local time equivalent to the supplied time
        return d;
    }

    function checkFromXmlDateTimePaths(value, childName, fullPath) {
        if(config.datetimeAccessFormPaths.length > 0) {
            var path = fullPath.split("\.#")[0];
            var idx = 0;
            for(; idx < config.datetimeAccessFormPaths.length; idx++) {
                var dtPath = config.datetimeAccessFormPaths[idx];
                if( typeof dtPath === "string" ) {
                    if(dtPath == path)
                        break;
                }
                else
                if( dtPath instanceof RegExp) {
                    if(dtPath.test(path))
                        break;
                }
                else
                if( typeof dtPath === "function") {
                    if(dtPath(obj, childName, path))
                        break;
                }
            }
            if(idx!=config.datetimeAccessFormPaths.length) {
                return fromXmlDateTime(value);
            }
            else
                return value;
        }
        else
            return value;
    }

    function parseDOMChildren( node, path ) {
        if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
            var result = new Object;
            var nodeChildren = node.childNodes;
            // Alternative for firstElementChild which is not supported in some environments
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx);
                if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
                    var childName = getNodeLocalName(child);
                    result[childName] = parseDOMChildren(child, childName);
                }
            }
            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
            var result = new Object;
            result.__cnt=0;

            var nodeChildren = node.childNodes;

            // Children nodes
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx); // nodeChildren[cidx];
                var childName = getNodeLocalName(child);

                if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
                    result.__cnt++;
                    if(result[childName] == null) {
                        result[childName] = parseDOMChildren(child, path+"."+childName);
                        toArrayAccessForm(result, childName, path+"."+childName);
                    }
                    else {
                        if(result[childName] != null) {
                            if( !(result[childName] instanceof Array)) {
                                result[childName] = [result[childName]];
                                toArrayAccessForm(result, childName, path+"."+childName);
                            }
                        }
                        (result[childName])[result[childName].length] = parseDOMChildren(child, path+"."+childName);
                    }
                }
            }

            // Attributes
            for(var aidx=0; aidx <node.attributes.length; aidx++) {
                var attr = node.attributes.item(aidx); // [aidx];
                result.__cnt++;
                result[config.attributePrefix+attr.name]=attr.value;
            }

            // Node namespace prefix
            var nodePrefix = getNodePrefix(node);
            if(nodePrefix!=null && nodePrefix!="") {
                result.__cnt++;
                result.__prefix=nodePrefix;
            }

            if(result["#text"]!=null) {
                result.__text = result["#text"];
                if(result.__text instanceof Array) {
                    result.__text = result.__text.join("\n");
                }
                if(config.escapeMode)
                    result.__text = unescapeXmlChars(result.__text);
                if(config.stripWhitespaces)
                    result.__text = result.__text.trim();
                delete result["#text"];
                if(config.arrayAccessForm=="property")
                    delete result["#text_asArray"];
                result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
            }
            if(result["#cdata-section"]!=null) {
                result.__cdata = result["#cdata-section"];
                delete result["#cdata-section"];
                if(config.arrayAccessForm=="property")
                    delete result["#cdata-section_asArray"];
            }

            if( result.__cnt == 1 && result.__text!=null  ) {
                result = result.__text;
            }
            else
            if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
                result = '';
            }
            else
            if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
                if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
                    delete result.__text;
                }
            }
            delete result.__cnt;

            if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
                result.toString = function() {
                    return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
                };
            }

            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
            return node.nodeValue;
        }
    }

    function startTag(jsonObj, element, attrList, closed) {
        var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
        if(attrList!=null) {
            for(var aidx = 0; aidx < attrList.length; aidx++) {
                var attrName = attrList[aidx];
                var attrVal = jsonObj[attrName];
                if(config.escapeMode)
                    attrVal=escapeXmlChars(attrVal);
                resultStr+=" "+attrName.substr(config.attributePrefix.length)+"='"+attrVal+"'";
            }
        }
        if(!closed)
            resultStr+=">";
        else
            resultStr+="/>";
        return resultStr;
    }

    function endTag(jsonObj,elementName) {
        return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
        if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray")))
            || jsonObjField.toString().indexOf(config.attributePrefix)==0
            || jsonObjField.toString().indexOf("__")==0
            || (jsonObj[jsonObjField] instanceof Function) )
            return true;
        else
            return false;
    }

    function jsonXmlElemCount ( jsonObj ) {
        var elementsCnt = 0;
        if(jsonObj instanceof Object ) {
            for( var it in jsonObj  ) {
                if(jsonXmlSpecialElem ( jsonObj, it) )
                    continue;
                elementsCnt++;
            }
        }
        return elementsCnt;
    }

    function parseJSONAttributes ( jsonObj ) {
        var attrList = [];
        if(jsonObj instanceof Object ) {
            for( var ait in jsonObj  ) {
                if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
                    attrList.push(ait);
                }
            }
        }
        return attrList;
    }

    function parseJSONTextAttrs ( jsonTxtObj ) {
        var result ="";

        if(jsonTxtObj.__cdata!=null) {
            result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";
        }

        if(jsonTxtObj.__text!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj.__text);
            else
                result+=jsonTxtObj.__text;
        }
        return result;
    }

    function parseJSONTextObject ( jsonTxtObj ) {
        var result ="";

        if( jsonTxtObj instanceof Object ) {
            result+=parseJSONTextAttrs ( jsonTxtObj );
        }
        else
        if(jsonTxtObj!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj);
            else
                result+=jsonTxtObj;
        }

        return result;
    }

    function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
        var result = "";
        if(jsonArrRoot.length == 0) {
            result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
        }
        else {
            for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
                result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
                result+=parseJSONObject(jsonArrRoot[arIdx]);
                result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
            }
        }
        return result;
    }

    function parseJSONObject ( jsonObj ) {
        var result = "";

        var elementsCnt = jsonXmlElemCount ( jsonObj );

        if(elementsCnt > 0) {
            for( var it in jsonObj ) {

                if(jsonXmlSpecialElem ( jsonObj, it) )
                    continue;

                var subObj = jsonObj[it];

                var attrList = parseJSONAttributes( subObj )

                if(subObj == null || subObj == undefined) {
                    result+=startTag(subObj, it, attrList, true);
                }
                else
                if(subObj instanceof Object) {

                    if(subObj instanceof Array) {
                        result+=parseJSONArray( subObj, it, attrList );
                    }
                    else if(subObj instanceof Date) {
                        result+=startTag(subObj, it, attrList, false);
                        result+=subObj.toISOString();
                        result+=endTag(subObj,it);
                    }
                    else {
                        var subObjElementsCnt = jsonXmlElemCount ( subObj );
                        if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
                            result+=startTag(subObj, it, attrList, false);
                            result+=parseJSONObject(subObj);
                            result+=endTag(subObj,it);
                        }
                        else {
                            result+=startTag(subObj, it, attrList, true);
                        }
                    }
                }
                else {
                    result+=startTag(subObj, it, attrList, false);
                    result+=parseJSONTextObject(subObj);
                    result+=endTag(subObj,it);
                }
            }
        }
        result+=parseJSONTextObject(jsonObj);

        return result;
    }

    this.parseXmlString = function(xmlDocStr) {
        var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
        if (xmlDocStr === undefined) {
            return null;
        }
        var xmlDoc;
        if (window.DOMParser) {
            var parser=new window.DOMParser();
            var parsererrorNS = null;
            // IE9+ now is here
            if(!isIEParser) {
                try {
                    parsererrorNS = parser.parseFromString("INVALID", "text/xml").childNodes[0].namespaceURI;
                }
                catch(err) {
                    parsererrorNS = null;
                }
            }
            try {
                xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
                if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
                    //throw new Error('Error parsing XML: '+xmlDocStr);
                    xmlDoc = null;
                }
            }
            catch(err) {
                xmlDoc = null;
            }
        }
        else {
            // IE :(
            if(xmlDocStr.indexOf("<?")==0) {
                xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
            }
            xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async="false";
            xmlDoc.loadXML(xmlDocStr);
        }
        return xmlDoc;
    };

    this.asArray = function(prop) {
        if(prop instanceof Array)
            return prop;
        else
            return [prop];
    };

    this.toXmlDateTime = function(dt) {
        if(dt instanceof Date)
            return dt.toISOString();
        else
        if(typeof(dt) === 'number' )
            return new Date(dt).toISOString();
        else
            return null;
    };

    this.asDateTime = function(prop) {
        if(typeof(prop) == "string") {
            return fromXmlDateTime(prop);
        }
        else
            return prop;
    };

    this.xml2json = function (xmlDoc) {
        return parseDOMChildren ( xmlDoc );
    };

    this.xml_str2json = function (xmlDocStr) {
        var xmlDoc = this.parseXmlString(xmlDocStr);
        if(xmlDoc!=null)
            return this.xml2json(xmlDoc);
        else
            return null;
    };

    this.json2xml_str = function (jsonObj) {
        return parseJSONObject ( jsonObj );
    };

    this.json2xml = function (jsonObj) {
        var xmlDocStr = this.json2xml_str (jsonObj);
        return this.parseXmlString(xmlDocStr);
    };

    this.getVersion = function () {
        return VERSION;
    };

}