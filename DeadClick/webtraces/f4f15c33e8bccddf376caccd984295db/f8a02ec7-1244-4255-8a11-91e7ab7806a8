



jQuery.cookie = function(name, value, options) {
if (typeof value != 'undefined') { 
 options = options || {};
if (value === null) {
value = '';
options.expires = -1;
}
var expires = '';
if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
var date;
if (typeof options.expires == 'number') {
date = new Date();
date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
} else {
date = options.expires;
}
expires = '; expires=' + date.toUTCString(); 
 }

 
 
 var path = options.path ? '; path=' + (options.path) : '';
var domain = options.domain ? '; domain=' + (options.domain) : '';
var secure = options.secure ? '; secure' : '';
document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
} else { 
 var cookieValue = null;
if (document.cookie && document.cookie != '') {
var cookies = document.cookie.split(';');
for (var i = 0; i < cookies.length; i++) {
var cookie = jQuery.trim(cookies[i]);

 if (cookie.substring(0, name.length + 1) == (name + '=')) {
cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
break;
}
}
}
return cookieValue;
}
};


(function($) {
$.expander = {
version: '1.4.13',
defaults: {

 slicePoint: 100,

 
 
 sliceOn: null,

 preserveWords: true,

 showWordCount: false,

 wordCountText: ' ({{count}} words)',

 
 
 widow: 4,

 
 expandText: 'read more',
expandPrefix: '&hellip; ',
expandAfterSummary: false,

 wordEnd: /(&(?:[^;]+;)?|[a-zA-Z\u00C0-\u0100]+|[^\u0000-\u007F]+)$/,

 summaryClass: 'summary',
detailClass: 'details',

 moreClass: 'read-more',
lessClass: 'read-less',

 moreLinkClass: 'more-link',
lessLinkClass: 'less-link',

 
 collapseTimer: 0,

 expandEffect: 'slideDown',
expandSpeed: 250,
collapseEffect: 'slideUp',
collapseSpeed: 200,

 userCollapse: true,

 userCollapseText: 'read less',
userCollapsePrefix: ' ',


onSlice: null, 
 beforeExpand: null, 
 afterExpand: null, 
 onCollapse: null, 
 afterCollapse: null 
 }
};
$.fn.expander = function(options) {
var meth = 'init';
if (typeof options === 'string') {
meth = options;
options = {};
}
var opts = $.extend({}, $.expander.defaults, options),
rSelfClose = /^<(?:area|br|col|embed|hr|img|input|link|meta|param).*>$/i,
rAmpWordEnd = opts.wordEnd,
rOpenCloseTag = /<\/?(\w+)[^>]*>/g,
rOpenTag = /<(\w+)[^>]*>/g,
rCloseTag = /<\/(\w+)>/g,
rLastCloseTag = /(<\/([^>]+)>)\s*$/,
rTagPlus = /^(<[^>]+>)+.?/,
rMultiSpace = /\s\s+/g,
delayedCollapse;
var removeSpaces = function(str) {
return $.trim( str || '' ).replace(rMultiSpace, ' ');
};
var methods = {
init: function() {
this.each(function() {
var i, l, tmp, newChar, summTagless, summOpens, summCloses,
lastCloseTag, detailText, detailTagless, html, expand,
$thisDetails, $readMore,
slicePointChanged,
openTagsForDetails = [],
closeTagsForsummaryText = [],
strayChars = '',
defined = {},
thisEl = this,
$this = $(this),
$summEl = $([]),
o = $.extend({}, opts, $this.data('expander') || $.meta && $this.data() || {}),
hasDetails = !!$this.find('.' + o.detailClass).length,
hasBlocks = !!$this.find('*').filter(function() {
var display = $(this).css('display');
return (/^block|table|list/).test(display);
}).length,
el = hasBlocks ? 'div' : 'span',
detailSelector = el + '.' + o.detailClass,
moreClass = o.moreClass + '',
lessClass = o.lessClass + '',
expandSpeed = o.expandSpeed || 0,
allHtml = removeSpaces( $this.html() ),
summaryText = allHtml.slice(0, o.slicePoint);

 o.moreSelector = 'span.' + moreClass.split(' ').join('.');
o.lessSelector = 'span.' + lessClass.split(' ').join('.');

 if ( $.data(this, 'expanderInit') ) {
return;
}
$.data(this, 'expanderInit', true);
$.data(this, 'expander', o);

 $.each(['onSlice','beforeExpand', 'afterExpand', 'onCollapse', 'afterCollapse'], function(index, val) {
defined[val] = $.isFunction(o[val]);
});

 summaryText = backup(summaryText);

 summTagless = summaryText.replace(rOpenCloseTag, '').length;

 while (summTagless < o.slicePoint) {
newChar = allHtml.charAt(summaryText.length);
if (newChar === '<') {
newChar = allHtml.slice(summaryText.length).match(rTagPlus)[0];
}
summaryText += newChar;
summTagless++;
}

 
 if (o.sliceOn) {
slicePointChanged = changeSlicePoint({
sliceOn: o.sliceOn,
slicePoint: o.slicePoint,
allHtml: allHtml,
summaryText: summaryText
});
summaryText = slicePointChanged.summaryText;
}
summaryText = backup(summaryText, o.preserveWords && allHtml.slice(summaryText.length).length);

 summOpens = summaryText.match(rOpenTag) || [];
summCloses = summaryText.match(rCloseTag) || [];

 tmp = [];
$.each(summOpens, function(index, val) {
if ( !rSelfClose.test(val) ) {
tmp.push(val);
}
});
summOpens = tmp;

 l = summCloses.length;
for (i = 0; i < l; i++) {
summCloses[i] = summCloses[i].replace(rCloseTag, '$1');
}

 
 
 $.each(summOpens, function(index, val) {
var thisTagName = val.replace(rOpenTag, '$1');
var closePosition = $.inArray(thisTagName, summCloses);
if (closePosition === -1) {
openTagsForDetails.push(val);
closeTagsForsummaryText.push('</' + thisTagName + '>');
} else {
summCloses.splice(closePosition, 1);
}
});

 closeTagsForsummaryText.reverse();

 if ( !hasDetails ) {

 detailText = allHtml.slice(summaryText.length);
detailTagless = $.trim( detailText.replace(rOpenCloseTag, '') );
if ( detailTagless === '' || detailTagless.split(/\s+/).length < o.widow ) {
return;
}

 lastCloseTag = closeTagsForsummaryText.pop() || '';
summaryText += closeTagsForsummaryText.join('');
detailText = openTagsForDetails.join('') + detailText;
} else {

 
 


 detailText = $this.find(detailSelector).remove().html();

 summaryText = $this.html();

 allHtml = summaryText + detailText;
lastCloseTag = '';
}
o.moreLabel = $this.find(o.moreSelector).length ? '' : buildMoreLabel(o, detailText);
if (hasBlocks) {
detailText = allHtml;

 } else if (summaryText.charAt(summaryText.length-1) === '&') {
strayChars = /^[#\w\d\\]+;/.exec(detailText);
if (strayChars) {
detailText = detailText.slice(strayChars[0].length);
summaryText += strayChars[0];
}
}
summaryText += lastCloseTag;

 o.summary = summaryText;
o.details = detailText;
o.lastCloseTag = lastCloseTag;
if (defined.onSlice) {

 
 
 tmp = o.onSlice.call(thisEl, o);

 o = tmp && tmp.details ? tmp : o;
}

 html = buildHTML(o, hasBlocks);
$this.html( html );

 $thisDetails = $this.find(detailSelector);
$readMore = $this.find(o.moreSelector);

 
 
 
 
 
 if (o.collapseEffect === 'slideUp' && o.expandEffect !== 'slideDown' || $this.is(':hidden')) {
$thisDetails.css({display: 'none'});
} else {
$thisDetails[o.collapseEffect](0);
}
$summEl = $this.find('div.' + o.summaryClass);
expand = function(event) {
event.preventDefault();
$readMore.hide();
$summEl.hide();
if (defined.beforeExpand) {
o.beforeExpand.call(thisEl);
}
$thisDetails.stop(false, true)[o.expandEffect](expandSpeed, function() {
$thisDetails.css({zoom: ''});
if (defined.afterExpand) {o.afterExpand.call(thisEl);}
delayCollapse(o, $thisDetails, thisEl);
});
};
$readMore.find('a').unbind('click.expander').bind('click.expander', expand);
if ( o.userCollapse && !$this.find(o.lessSelector).length ) {
$this
.find(detailSelector)
.append('<span class="' + o.lessClass + '">' + o.userCollapsePrefix + '<a href="#" class="'+ o.lessLinkClass +'">' + o.userCollapseText + '</a></span>');
}
$this
.find(o.lessSelector + ' a')
.unbind('click.expander')
.bind('click.expander', function(event) {
event.preventDefault();
clearTimeout(delayedCollapse);
var $detailsCollapsed = $(this).closest(detailSelector);
reCollapse(o, $detailsCollapsed);
if (defined.onCollapse) {
o.onCollapse.call(thisEl, true);
}
});
}); 
 },
destroy: function() {
this.each(function() {
var o, details,
$this = $(this);
if ( !$this.data('expanderInit') ) {
return;
}
o = $.extend({}, $this.data('expander') || {}, opts);
details = $this.find('.' + o.detailClass).contents();
$this.removeData('expanderInit');
$this.removeData('expander');
$this.find(o.moreSelector).remove();
$this.find('.' + o.summaryClass).remove();
$this.find('.' + o.detailClass).after(details).remove();
$this.find(o.lessSelector).remove();
});
}
};

 if ( methods[meth] ) {
methods[ meth ].call(this);
}

 function buildHTML(o, blocks) {
var el = 'span',
summary = o.summary,
closingTagParts = rLastCloseTag.exec(summary),
closingTag = closingTagParts ? closingTagParts[2].toLowerCase() : '';
if ( blocks ) {
el = 'div';

 if ( closingTagParts && closingTag !== 'a' && !o.expandAfterSummary ) {
summary = summary.replace(rLastCloseTag, o.moreLabel + '$1');
} else {

 
 summary += o.moreLabel;
}

 summary = '<div class="' + o.summaryClass + '">' + summary + '</div>';
} else {
summary += o.moreLabel;
}
return [
summary,
' <',
el + ' class="' + o.detailClass + '"',
'>',
o.details,
'</' + el + '>'
].join('');
}
function buildMoreLabel(o, detailText) {
var ret = '<span class="' + o.moreClass + '">' + o.expandPrefix;
if (o.showWordCount) {
o.wordCountText = o.wordCountText.replace(/\{\{count\}\}/, detailText.replace(rOpenCloseTag, '').replace(/\&(?:amp|nbsp);/g, '').replace(/(?:^\s+|\s+$)/, '').match(/\w+/g).length);
} else {
o.wordCountText = '';
}
ret += '<a href="#" class="' + o.moreLinkClass + '">' + o.expandText + o.wordCountText + '</a></span>';
return ret;
}
function backup(txt, preserveWords) {
if ( txt.lastIndexOf('<') > txt.lastIndexOf('>') ) {
txt = txt.slice( 0, txt.lastIndexOf('<') );
}
if (preserveWords) {
txt = txt.replace(rAmpWordEnd,'');
}
return $.trim(txt);
}
function reCollapse(o, el) {
el.stop(true, true)[o.collapseEffect](o.collapseSpeed, function() {
var prevMore = el.prev('span.' + o.moreClass).show();
if (!prevMore.length) {
el.parent().children('div.' + o.summaryClass).show()
.find('span.' + o.moreClass).show();
}
if (o.afterCollapse) {o.afterCollapse.call(el);}
});
}
function delayCollapse(option, $collapseEl, thisEl) {
if (option.collapseTimer) {
delayedCollapse = setTimeout(function() {
reCollapse(option, $collapseEl);
if ( $.isFunction(option.onCollapse) ) {
option.onCollapse.call(thisEl, false);
}
}, option.collapseTimer);
}
}
function changeSlicePoint(info) {

 var sliceOnTemp = 'ExpandMoreHere374216623';

 
 var summaryTextClean = info.summaryText.replace(info.sliceOn, sliceOnTemp);
summaryTextClean = $('<div>' + summaryTextClean + '</div>').text();

 var sliceOnIndexClean = summaryTextClean.indexOf(sliceOnTemp);

 var sliceOnIndexHtml = info.summaryText.indexOf(info.sliceOn);

 if (sliceOnIndexClean !== -1 && sliceOnIndexClean < info.slicePoint) {

 info.summaryText = info.allHtml.slice(0, sliceOnIndexHtml);
}
return info;
}
return this;
};

 $.fn.expander.defaults = $.expander.defaults;
})(jQuery);


;(function($, undefined) {
"use strict";
var ver = '2.9999.4';

if ($.support === undefined) {
$.support = {
opacity: !($.browser.msie)
};
}
function debug(s) {
if ($.fn.cycle.debug)
log(s);
} 
function log() {
if (window.console && console.log)
console.log('[cycle] ' + Array.prototype.join.call(arguments,' '));
}
$.expr[':'].paused = function(el) {
return el.cyclePause;
};










$.fn.cycle = function(options, arg2) {
var o = { s: this.selector, c: this.context };

	if (this.length === 0 && options != 'stop') {
if (!$.isReady && o.s) {
log('DOM not ready, queuing slideshow');
$(function() {
$(o.s,o.c).cycle(options,arg2);
});
return this;
}

 log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
return this;
}

	return this.each(function() {
var opts = handleArguments(this, options, arg2);
if (opts === false)
return;
opts.updateActivePagerLink = opts.updateActivePagerLink || $.fn.cycle.updateActivePagerLink;

 if (this.cycleTimeout)
clearTimeout(this.cycleTimeout);
this.cycleTimeout = this.cyclePause = 0;
var $cont = $(this);
var $slides = opts.slideExpr ? $(opts.slideExpr, this) : $cont.children();
var els = $slides.get();
if (els.length < 2) {
log('terminating; too few slides: ' + els.length);
return;
}
var opts2 = buildOptions($cont, $slides, els, opts, o);
if (opts2 === false)
return;
var startTime = opts2.continuous ? 10 : getTimeout(els[opts2.currSlide], els[opts2.nextSlide], opts2, !opts2.backwards);

 if (startTime) {
startTime += (opts2.delay || 0);
if (startTime < 10)
startTime = 10;
debug('first timeout: ' + startTime);
this.cycleTimeout = setTimeout(function(){go(els,opts2,0,!opts.backwards);}, startTime);
}
});
};
function triggerPause(cont, byHover, onPager) {
var opts = $(cont).data('cycle.opts');
var paused = !!cont.cyclePause;
if (paused && opts.paused)
opts.paused(cont, opts, byHover, onPager);
else if (!paused && opts.resumed)
opts.resumed(cont, opts, byHover, onPager);
}

function handleArguments(cont, options, arg2) {
if (cont.cycleStop === undefined)
cont.cycleStop = 0;
if (options === undefined || options === null)
options = {};
if (options.constructor == String) {
switch(options) {
case 'destroy':
case 'stop':
var opts = $(cont).data('cycle.opts');
if (!opts)
return false;
cont.cycleStop++; 
 if (cont.cycleTimeout)
clearTimeout(cont.cycleTimeout);
cont.cycleTimeout = 0;
if (opts.elements)
$(opts.elements).stop();
$(cont).removeData('cycle.opts');
if (options == 'destroy')
destroy(cont, opts);
return false;
case 'toggle':
cont.cyclePause = (cont.cyclePause === 1) ? 0 : 1;
checkInstantResume(cont.cyclePause, arg2, cont);
triggerPause(cont);
return false;
case 'pause':
cont.cyclePause = 1;
triggerPause(cont);
return false;
case 'resume':
cont.cyclePause = 0;
checkInstantResume(false, arg2, cont);
triggerPause(cont);
return false;
case 'prev':
case 'next':
opts = $(cont).data('cycle.opts');
if (!opts) {
log('options not found, "prev/next" ignored');
return false;
}
$.fn.cycle[options](opts);
return false;
default:
options = { fx: options };
}
return options;
}
else if (options.constructor == Number) {

 var num = options;
options = $(cont).data('cycle.opts');
if (!options) {
log('options not found, can not advance slide');
return false;
}
if (num < 0 || num >= options.elements.length) {
log('invalid slide index: ' + num);
return false;
}
options.nextSlide = num;
if (cont.cycleTimeout) {
clearTimeout(cont.cycleTimeout);
cont.cycleTimeout = 0;
}
if (typeof arg2 == 'string')
options.oneTimeFx = arg2;
go(options.elements, options, 1, num >= options.currSlide);
return false;
}
return options;
function checkInstantResume(isPaused, arg2, cont) {
if (!isPaused && arg2 === true) { 
 var options = $(cont).data('cycle.opts');
if (!options) {
log('options not found, can not resume');
return false;
}
if (cont.cycleTimeout) {
clearTimeout(cont.cycleTimeout);
cont.cycleTimeout = 0;
}
go(options.elements, options, 1, !options.backwards);
}
}
}
function removeFilter(el, opts) {
if (!$.support.opacity && opts.cleartype && el.style.filter) {
try { el.style.removeAttribute('filter'); }
catch(smother) {} 
	}
}
function getStyle(el,styleProp) {
el = document.getElementById(el);
var result;
if(el.currentStyle) {
result = el.currentStyle[styleProp];
} else if (window.getComputedStyle) {
result = document.defaultView.getComputedStyle(el,null)
.getPropertyValue(styleProp);
} else {
result = 'unknown';
}
return result;
}

function destroy(cont, opts) {
if (opts.next)
$(opts.next).unbind(opts.prevNextEvent);
if (opts.prev)
$(opts.prev).unbind(opts.prevNextEvent);
if (opts.pager || opts.pagerAnchorBuilder)
$.each(opts.pagerAnchors || [], function() {
this.unbind().remove();
});
opts.pagerAnchors = null;
$(cont).unbind('mouseenter.cycle mouseleave.cycle');
if (opts.destroy) 
 opts.destroy(opts);
}

function buildOptions($cont, $slides, els, options, o) {
var startingSlideSpecified;

	var opts = $.extend({}, $.fn.cycle.defaults, options || {}, $.metadata ? $cont.metadata() : $.meta ? $cont.data() : {});
var meta = $.isFunction($cont.data) ? $cont.data(opts.metaAttr) : null;
if (meta)
opts = $.extend(opts, meta);
if (opts.autostop)
opts.countdown = opts.autostopCount || els.length;
var cont = $cont[0];
$cont.data('cycle.opts', opts);
opts.$cont = $cont;
opts.stopCount = cont.cycleStop;
opts.elements = els;
opts.before = opts.before ? [opts.before] : [];
opts.after = opts.after ? [opts.after] : [];

	if (!$.support.opacity && opts.cleartype)
opts.after.push(function() { removeFilter(this, opts); });
if (opts.continuous)
opts.after.push(function() { go(els,opts,0,!opts.backwards); });
saveOriginalOpts(opts);

	if (!$.support.opacity && opts.cleartype && !opts.cleartypeNoBg)
clearTypeFix($slides);

	if ($cont.css('position') == 'static')
$cont.css('position', 'relative');
if (opts.width)
$cont.width(opts.width);
if (opts.height && opts.height != 'auto')
$cont.height(opts.height);
if (opts.startingSlide !== undefined) {
opts.startingSlide = parseInt(opts.startingSlide,10);
if (opts.startingSlide >= els.length || opts.startSlide < 0)
opts.startingSlide = 0; 
 else
startingSlideSpecified = true;
}
else if (opts.backwards)
opts.startingSlide = els.length - 1;
else
opts.startingSlide = 0;

	if (opts.random) {
opts.randomMap = [];
for (var i = 0; i < els.length; i++)
opts.randomMap.push(i);
opts.randomMap.sort(function(a,b) {return Math.random() - 0.5;});
if (startingSlideSpecified) {

 for ( var cnt = 0; cnt < els.length; cnt++ ) {
if ( opts.startingSlide == opts.randomMap[cnt] ) {
opts.randomIndex = cnt;
}
}
}
else {
opts.randomIndex = 1;
opts.startingSlide = opts.randomMap[1];
}
}
else if (opts.startingSlide >= els.length)
opts.startingSlide = 0; 
	opts.currSlide = opts.startingSlide || 0;
var first = opts.startingSlide;

	$slides.css({position: 'absolute', top:0, left:0}).hide().each(function(i) {
var z;
if (opts.backwards)
z = first ? i <= first ? els.length + (i-first) : first-i : els.length-i;
else
z = first ? i >= first ? els.length - (i-first) : first-i : els.length-i;
$(this).css('z-index', z);
});

	$(els[first]).css('opacity',1).show(); 
	removeFilter(els[first], opts);

	if (opts.fit) {
if (!opts.aspect) {
if (opts.width)
$slides.width(opts.width);
if (opts.height && opts.height != 'auto')
$slides.height(opts.height);
} else {
$slides.each(function(){
var $slide = $(this);
var ratio = (opts.aspect === true) ? $slide.width()/$slide.height() : opts.aspect;
if( opts.width && $slide.width() != opts.width ) {
$slide.width( opts.width );
$slide.height( opts.width / ratio );
}
if( opts.height && $slide.height() < opts.height ) {
$slide.height( opts.height );
$slide.width( opts.height * ratio );
}
});
}
}
if (opts.center && ((!opts.fit) || opts.aspect)) {
$slides.each(function(){
var $slide = $(this);
$slide.css({
"margin-left": opts.width ?
((opts.width - $slide.width()) / 2) + "px" :
0,
"margin-top": opts.height ?
((opts.height - $slide.height()) / 2) + "px" :
0
});
});
}
if (opts.center && !opts.fit && !opts.slideResize) {
$slides.each(function(){
var $slide = $(this);
$slide.css({
"margin-left": opts.width ? ((opts.width - $slide.width()) / 2) + "px" : 0,
"margin-top": opts.height ? ((opts.height - $slide.height()) / 2) + "px" : 0
});
});
}

	var reshape = opts.containerResize && !$cont.innerHeight();
if (reshape) { 
 var maxw = 0, maxh = 0;
for(var j=0; j < els.length; j++) {
var $e = $(els[j]), e = $e[0], w = $e.outerWidth(), h = $e.outerHeight();
if (!w) w = e.offsetWidth || e.width || $e.attr('width');
if (!h) h = e.offsetHeight || e.height || $e.attr('height');
maxw = w > maxw ? w : maxw;
maxh = h > maxh ? h : maxh;
}
if (maxw > 0 && maxh > 0)
$cont.css({width:maxw+'px',height:maxh+'px'});
}
var pauseFlag = false; 
	if (opts.pause)
$cont.bind('mouseenter.cycle', function(){
pauseFlag = true;
this.cyclePause++;
triggerPause(cont, true);
}).bind('mouseleave.cycle', function(){
if (pauseFlag)
this.cyclePause--;
triggerPause(cont, true);
});
if (supportMultiTransitions(opts) === false)
return false;

	
	var requeue = false;
options.requeueAttempts = options.requeueAttempts || 0;
$slides.each(function() {

 var $el = $(this);
this.cycleH = (opts.fit && opts.height) ? opts.height : ($el.height() || this.offsetHeight || this.height || $el.attr('height') || 0);
this.cycleW = (opts.fit && opts.width) ? opts.width : ($el.width() || this.offsetWidth || this.width || $el.attr('width') || getStyle($el,'width') || 0);
if ( $el.is('img') ) {

 
 
 var loadingIE	= ($.browser.msie && this.cycleW == 28 && this.cycleH == 30 && !this.complete);
var loadingFF	= ($.browser.mozilla && this.cycleW == 34 && this.cycleH == 19 && !this.complete);
var loadingOp	= ($.browser.opera && ((this.cycleW == 42 && this.cycleH == 19) || (this.cycleW == 37 && this.cycleH == 17)) && !this.complete);
var loadingOther = (this.cycleH === 0 && this.cycleW === 0 && !this.complete);

 if (loadingIE || loadingFF || loadingOp || loadingOther) {
if (o.s && opts.requeueOnImageNotLoaded && ++options.requeueAttempts < 100) { 
 log(options.requeueAttempts,' - img slide not loaded, requeuing slideshow: ', this.src, this.cycleW, this.cycleH);
setTimeout(function() {$(o.s,o.c).cycle(options);}, opts.requeueTimeout);
requeue = true;
return false; 
 }
else {
log('could not determine size of image: '+this.src, this.cycleW, this.cycleH);
}
}
}
return true;
});
if (requeue)
return false;
opts.cssBefore = opts.cssBefore || {};
opts.cssAfter = opts.cssAfter || {};
opts.cssFirst = opts.cssFirst || {};
opts.animIn = opts.animIn || {};
opts.animOut = opts.animOut || {};
$slides.not(':eq('+first+')').css(opts.cssBefore);
$($slides[first]).css(opts.cssFirst);
if (opts.timeout) {
opts.timeout = parseInt(opts.timeout,10);

 if (opts.speed.constructor == String)
opts.speed = $.fx.speeds[opts.speed] || parseInt(opts.speed,10);
if (!opts.sync)
opts.speed = opts.speed / 2;
var buffer = opts.fx == 'none' ? 0 : opts.fx == 'shuffle' ? 500 : 250;
while((opts.timeout - opts.speed) < buffer) 
 opts.timeout += opts.speed;
}
if (opts.easing)
opts.easeIn = opts.easeOut = opts.easing;
if (!opts.speedIn)
opts.speedIn = opts.speed;
if (!opts.speedOut)
opts.speedOut = opts.speed;
opts.slideCount = els.length;
opts.currSlide = opts.lastSlide = first;
if (opts.random) {
if (++opts.randomIndex == els.length)
opts.randomIndex = 0;
opts.nextSlide = opts.randomMap[opts.randomIndex];
}
else if (opts.backwards)
opts.nextSlide = opts.startingSlide === 0 ? (els.length-1) : opts.startingSlide-1;
else
opts.nextSlide = opts.startingSlide >= (els.length-1) ? 0 : opts.startingSlide+1;

	if (!opts.multiFx) {
var init = $.fn.cycle.transitions[opts.fx];
if ($.isFunction(init))
init($cont, $slides, opts);
else if (opts.fx != 'custom' && !opts.multiFx) {
log('unknown transition: ' + opts.fx,'; slideshow terminating');
return false;
}
}

	var e0 = $slides[first];
if (!opts.skipInitializationCallbacks) {
if (opts.before.length)
opts.before[0].apply(e0, [e0, e0, opts, true]);
if (opts.after.length)
opts.after[0].apply(e0, [e0, e0, opts, true]);
}
if (opts.next)
$(opts.next).bind(opts.prevNextEvent,function(){return advance(opts,1);});
if (opts.prev)
$(opts.prev).bind(opts.prevNextEvent,function(){return advance(opts,0);});
if (opts.pager || opts.pagerAnchorBuilder)
buildPager(els,opts);
exposeAddSlide(opts, els);
return opts;
}

function saveOriginalOpts(opts) {
opts.original = { before: [], after: [] };
opts.original.cssBefore = $.extend({}, opts.cssBefore);
opts.original.cssAfter = $.extend({}, opts.cssAfter);
opts.original.animIn	= $.extend({}, opts.animIn);
opts.original.animOut = $.extend({}, opts.animOut);
$.each(opts.before, function() { opts.original.before.push(this); });
$.each(opts.after, function() { opts.original.after.push(this); });
}
function supportMultiTransitions(opts) {
var i, tx, txs = $.fn.cycle.transitions;

	if (opts.fx.indexOf(',') > 0) {
opts.multiFx = true;
opts.fxs = opts.fx.replace(/\s*/g,'').split(',');

 for (i=0; i < opts.fxs.length; i++) {
var fx = opts.fxs[i];
tx = txs[fx];
if (!tx || !txs.hasOwnProperty(fx) || !$.isFunction(tx)) {
log('discarding unknown transition: ',fx);
opts.fxs.splice(i,1);
i--;
}
}

 if (!opts.fxs.length) {
log('No valid transitions named; slideshow terminating.');
return false;
}
}
else if (opts.fx == 'all') { 
 opts.multiFx = true;
opts.fxs = [];
for (var p in txs) {
if (txs.hasOwnProperty(p)) {
tx = txs[p];
if (txs.hasOwnProperty(p) && $.isFunction(tx))
opts.fxs.push(p);
}
}
}
if (opts.multiFx && opts.randomizeEffects) {

 var r1 = Math.floor(Math.random() * 20) + 30;
for (i = 0; i < r1; i++) {
var r2 = Math.floor(Math.random() * opts.fxs.length);
opts.fxs.push(opts.fxs.splice(r2,1)[0]);
}
debug('randomized fx sequence: ',opts.fxs);
}
return true;
}

function exposeAddSlide(opts, els) {
opts.addSlide = function(newSlide, prepend) {
var $s = $(newSlide), s = $s[0];
if (!opts.autostopCount)
opts.countdown++;
els[prepend?'unshift':'push'](s);
if (opts.els)
opts.els[prepend?'unshift':'push'](s); 
 opts.slideCount = els.length;

 if (opts.random) {
opts.randomMap.push(opts.slideCount-1);
opts.randomMap.sort(function(a,b) {return Math.random() - 0.5;});
}
$s.css('position','absolute');
$s[prepend?'prependTo':'appendTo'](opts.$cont);
if (prepend) {
opts.currSlide++;
opts.nextSlide++;
}
if (!$.support.opacity && opts.cleartype && !opts.cleartypeNoBg)
clearTypeFix($s);
if (opts.fit && opts.width)
$s.width(opts.width);
if (opts.fit && opts.height && opts.height != 'auto')
$s.height(opts.height);
s.cycleH = (opts.fit && opts.height) ? opts.height : $s.height();
s.cycleW = (opts.fit && opts.width) ? opts.width : $s.width();
$s.css(opts.cssBefore);
if (opts.pager || opts.pagerAnchorBuilder)
$.fn.cycle.createPagerAnchor(els.length-1, s, $(opts.pager), els, opts);
if ($.isFunction(opts.onAddSlide))
opts.onAddSlide($s);
else
$s.hide(); 
	};
}

$.fn.cycle.resetState = function(opts, fx) {
fx = fx || opts.fx;
opts.before = []; opts.after = [];
opts.cssBefore = $.extend({}, opts.original.cssBefore);
opts.cssAfter = $.extend({}, opts.original.cssAfter);
opts.animIn	= $.extend({}, opts.original.animIn);
opts.animOut = $.extend({}, opts.original.animOut);
opts.fxFn = null;
$.each(opts.original.before, function() { opts.before.push(this); });
$.each(opts.original.after, function() { opts.after.push(this); });

	var init = $.fn.cycle.transitions[fx];
if ($.isFunction(init))
init(opts.$cont, $(opts.elements), opts);
};

function go(els, opts, manual, fwd) {
var p = opts.$cont[0], curr = els[opts.currSlide], next = els[opts.nextSlide];

	if (manual && opts.busy && opts.manualTrump) {

 debug('manualTrump in go(), stopping active transition');
$(els).stop(true,true);
opts.busy = 0;
clearTimeout(p.cycleTimeout);
}

	if (opts.busy) {
debug('transition active, ignoring new tx request');
return;
}

	if (p.cycleStop != opts.stopCount || p.cycleTimeout === 0 && !manual)
return;

	if (!manual && !p.cyclePause && !opts.bounce &&
((opts.autostop && (--opts.countdown <= 0)) ||
(opts.nowrap && !opts.random && opts.nextSlide < opts.currSlide))) {
if (opts.end)
opts.end(opts);
return;
}

	var changed = false;
if ((manual || !p.cyclePause) && (opts.nextSlide != opts.currSlide)) {
changed = true;
var fx = opts.fx;

 curr.cycleH = curr.cycleH || $(curr).height();
curr.cycleW = curr.cycleW || $(curr).width();
next.cycleH = next.cycleH || $(next).height();
next.cycleW = next.cycleW || $(next).width();

 if (opts.multiFx) {
if (fwd && (opts.lastFx === undefined || ++opts.lastFx >= opts.fxs.length))
opts.lastFx = 0;
else if (!fwd && (opts.lastFx === undefined || --opts.lastFx < 0))
opts.lastFx = opts.fxs.length - 1;
fx = opts.fxs[opts.lastFx];
}

 if (opts.oneTimeFx) {
fx = opts.oneTimeFx;
opts.oneTimeFx = null;
}
$.fn.cycle.resetState(opts, fx);

 if (opts.before.length)
$.each(opts.before, function(i,o) {
if (p.cycleStop != opts.stopCount) return;
o.apply(next, [curr, next, opts, fwd]);
});

 var after = function() {
opts.busy = 0;
$.each(opts.after, function(i,o) {
if (p.cycleStop != opts.stopCount) return;
o.apply(next, [curr, next, opts, fwd]);
});
if (!p.cycleStop) {

 queueNext();
}
};
debug('tx firing('+fx+'); currSlide: ' + opts.currSlide + '; nextSlide: ' + opts.nextSlide);

 opts.busy = 1;
if (opts.fxFn) 
 opts.fxFn(curr, next, opts, after, fwd, manual && opts.fastOnEvent);
else if ($.isFunction($.fn.cycle[opts.fx])) 
 $.fn.cycle[opts.fx](curr, next, opts, after, fwd, manual && opts.fastOnEvent);
else
$.fn.cycle.custom(curr, next, opts, after, fwd, manual && opts.fastOnEvent);
}
else {
queueNext();
}
if (changed || opts.nextSlide == opts.currSlide) {

 var roll;
opts.lastSlide = opts.currSlide;
if (opts.random) {
opts.currSlide = opts.nextSlide;
if (++opts.randomIndex == els.length) {
opts.randomIndex = 0;
opts.randomMap.sort(function(a,b) {return Math.random() - 0.5;});
}
opts.nextSlide = opts.randomMap[opts.randomIndex];
if (opts.nextSlide == opts.currSlide)
opts.nextSlide = (opts.currSlide == opts.slideCount - 1) ? 0 : opts.currSlide + 1;
}
else if (opts.backwards) {
roll = (opts.nextSlide - 1) < 0;
if (roll && opts.bounce) {
opts.backwards = !opts.backwards;
opts.nextSlide = 1;
opts.currSlide = 0;
}
else {
opts.nextSlide = roll ? (els.length-1) : opts.nextSlide-1;
opts.currSlide = roll ? 0 : opts.nextSlide+1;
}
}
else { 
 roll = (opts.nextSlide + 1) == els.length;
if (roll && opts.bounce) {
opts.backwards = !opts.backwards;
opts.nextSlide = els.length-2;
opts.currSlide = els.length-1;
}
else {
opts.nextSlide = roll ? 0 : opts.nextSlide+1;
opts.currSlide = roll ? els.length-1 : opts.nextSlide-1;
}
}
}
if (changed && opts.pager)
opts.updateActivePagerLink(opts.pager, opts.currSlide, opts.activePagerClass);
function queueNext() {

 var ms = 0, timeout = opts.timeout;
if (opts.timeout && !opts.continuous) {
ms = getTimeout(els[opts.currSlide], els[opts.nextSlide], opts, fwd);
if (opts.fx == 'shuffle')
ms -= opts.speedOut;
}
else if (opts.continuous && p.cyclePause) 
 ms = 10;
if (ms > 0)
p.cycleTimeout = setTimeout(function(){ go(els, opts, 0, !opts.backwards); }, ms);
}
}

$.fn.cycle.updateActivePagerLink = function(pager, currSlide, clsName) {
$(pager).each(function() {
$(this).children().removeClass(clsName).eq(currSlide).addClass(clsName);
});
};

function getTimeout(curr, next, opts, fwd) {
if (opts.timeoutFn) {

 var t = opts.timeoutFn.call(curr,curr,next,opts,fwd);
while (opts.fx != 'none' && (t - opts.speed) < 250) 
 t += opts.speed;
debug('calculated timeout: ' + t + '; speed: ' + opts.speed);
if (t !== false)
return t;
}
return opts.timeout;
}

$.fn.cycle.next = function(opts) { advance(opts,1); };
$.fn.cycle.prev = function(opts) { advance(opts,0);};

function advance(opts, moveForward) {
var val = moveForward ? 1 : -1;
var els = opts.elements;
var p = opts.$cont[0], timeout = p.cycleTimeout;
if (timeout) {
clearTimeout(timeout);
p.cycleTimeout = 0;
}
if (opts.random && val < 0) {

 opts.randomIndex--;
if (--opts.randomIndex == -2)
opts.randomIndex = els.length-2;
else if (opts.randomIndex == -1)
opts.randomIndex = els.length-1;
opts.nextSlide = opts.randomMap[opts.randomIndex];
}
else if (opts.random) {
opts.nextSlide = opts.randomMap[opts.randomIndex];
}
else {
opts.nextSlide = opts.currSlide + val;
if (opts.nextSlide < 0) {
if (opts.nowrap) return false;
opts.nextSlide = els.length - 1;
}
else if (opts.nextSlide >= els.length) {
if (opts.nowrap) return false;
opts.nextSlide = 0;
}
}
var cb = opts.onPrevNextEvent || opts.prevNextClick; 
	if ($.isFunction(cb))
cb(val > 0, opts.nextSlide, els[opts.nextSlide]);
go(els, opts, 1, moveForward);
return false;
}
function buildPager(els, opts) {
var $p = $(opts.pager);
$.each(els, function(i,o) {
$.fn.cycle.createPagerAnchor(i,o,$p,els,opts);
});
opts.updateActivePagerLink(opts.pager, opts.startingSlide, opts.activePagerClass);
}
$.fn.cycle.createPagerAnchor = function(i, el, $p, els, opts) {
var a;
if ($.isFunction(opts.pagerAnchorBuilder)) {
a = opts.pagerAnchorBuilder(i,el);
debug('pagerAnchorBuilder('+i+', el) returned: ' + a);
}
else
a = '<a href="#">'+(i+1)+'</a>';
if (!a)
return;
var $a = $(a);

	if ($a.parents('body').length === 0) {
var arr = [];
if ($p.length > 1) {
$p.each(function() {
var $clone = $a.clone(true);
$(this).append($clone);
arr.push($clone[0]);
});
$a = $(arr);
}
else {
$a.appendTo($p);
}
}
opts.pagerAnchors = opts.pagerAnchors || [];
opts.pagerAnchors.push($a);
var pagerFn = function(e) {
e.preventDefault();
opts.nextSlide = i;
var p = opts.$cont[0], timeout = p.cycleTimeout;
if (timeout) {
clearTimeout(timeout);
p.cycleTimeout = 0;
}
var cb = opts.onPagerEvent || opts.pagerClick; 
 if ($.isFunction(cb))
cb(opts.nextSlide, els[opts.nextSlide]);
go(els,opts,1,opts.currSlide < i); 

	};
if ( /mouseenter|mouseover/i.test(opts.pagerEvent) ) {
$a.hover(pagerFn, function(){} );
}
else {
$a.bind(opts.pagerEvent, pagerFn);
}
if ( ! /^click/.test(opts.pagerEvent) && !opts.allowPagerClickBubble)
$a.bind('click.cycle', function(){return false;}); 

var cont = opts.$cont[0];
var pauseFlag = false; 
	if (opts.pauseOnPagerHover) {
$a.hover(
function() {
pauseFlag = true;
cont.cyclePause++;
triggerPause(cont,true,true);
}, function() {
if (pauseFlag)
cont.cyclePause--;
triggerPause(cont,true,true);
}
);
}
};

$.fn.cycle.hopsFromLast = function(opts, fwd) {
var hops, l = opts.lastSlide, c = opts.currSlide;
if (fwd)
hops = c > l ? c - l : opts.slideCount - l;
else
hops = c < l ? l - c : l + opts.slideCount - c;
return hops;
};


function clearTypeFix($slides) {
debug('applying clearType background-color hack');
function hex(s) {
s = parseInt(s,10).toString(16);
return s.length < 2 ? '0'+s : s;
}
function getBg(e) {
for ( ; e && e.nodeName.toLowerCase() != 'html'; e = e.parentNode) {
var v = $.css(e,'background-color');
if (v && v.indexOf('rgb') >= 0 ) {
var rgb = v.match(/\d+/g);
return '#'+ hex(rgb[0]) + hex(rgb[1]) + hex(rgb[2]);
}
if (v && v != 'transparent')
return v;
}
return '#ffffff';
}
$slides.each(function() { $(this).css('background-color', getBg(this)); });
}

$.fn.cycle.commonReset = function(curr,next,opts,w,h,rev) {
$(opts.elements).not(curr).hide();
if (typeof opts.cssBefore.opacity == 'undefined')
opts.cssBefore.opacity = 1;
opts.cssBefore.display = 'block';
if (opts.slideResize && w !== false && next.cycleW > 0)
opts.cssBefore.width = next.cycleW;
if (opts.slideResize && h !== false && next.cycleH > 0)
opts.cssBefore.height = next.cycleH;
opts.cssAfter = opts.cssAfter || {};
opts.cssAfter.display = 'none';
$(curr).css('zIndex',opts.slideCount + (rev === true ? 1 : 0));
$(next).css('zIndex',opts.slideCount + (rev === true ? 0 : 1));
};

$.fn.cycle.custom = function(curr, next, opts, cb, fwd, speedOverride) {
var $l = $(curr), $n = $(next);
var speedIn = opts.speedIn, speedOut = opts.speedOut, easeIn = opts.easeIn, easeOut = opts.easeOut;
$n.css(opts.cssBefore);
if (speedOverride) {
if (typeof speedOverride == 'number')
speedIn = speedOut = speedOverride;
else
speedIn = speedOut = 1;
easeIn = easeOut = null;
}
var fn = function() {
$n.animate(opts.animIn, speedIn, easeIn, function() {
cb();
});
};
$l.animate(opts.animOut, speedOut, easeOut, function() {
$l.css(opts.cssAfter);
if (!opts.sync)
fn();
});
if (opts.sync) fn();
};

$.fn.cycle.transitions = {
fade: function($cont, $slides, opts) {
$slides.not(':eq('+opts.currSlide+')').css('opacity',0);
opts.before.push(function(curr,next,opts) {
$.fn.cycle.commonReset(curr,next,opts);
opts.cssBefore.opacity = 0;
});
opts.animIn = { opacity: 1 };
opts.animOut = { opacity: 0 };
opts.cssBefore = { top: 0, left: 0 };
}
};
$.fn.cycle.ver = function() { return ver; };

$.fn.cycle.defaults = {
activePagerClass: 'activeSlide', 
 after: null, 
 allowPagerClickBubble: false, 
 animIn: null, 
 animOut: null, 
 aspect: false, 
 autostop: 0, 
 autostopCount: 0, 
 backwards: false, 
 before: null, 
 center: null, 
 cleartype: !$.support.opacity, 
 cleartypeNoBg: false, 
 containerResize: 1, 
 continuous: 0, 
 cssAfter: null, 
 cssBefore: null, 
 delay: 0, 
 easeIn: null, 
 easeOut: null, 
 easing: null, 
 end: null, 
 fastOnEvent: 0, 
 fit: 0, 
 fx: 'fade', 
 fxFn: null, 
 height: 'auto', 
 manualTrump: true, 
 metaAttr: 'cycle', 
 next: null, 
 nowrap: 0, 
 onPagerEvent: null, 
 onPrevNextEvent: null, 
 pager: null, 
 pagerAnchorBuilder: null, 
 pagerEvent: 'click.cycle', 
 pause: 0, 
 pauseOnPagerHover: 0, 
 prev: null, 
 prevNextEvent: 'click.cycle',
 random: 0, 
 randomizeEffects: 1, 
 requeueOnImageNotLoaded: true, 
 requeueTimeout: 250, 
 rev: 0, 
 shuffle: null, 
 skipInitializationCallbacks: false, 
 slideExpr: null, 
 slideResize: 1, 
 speed: 1000, 
 speedIn: null, 
 speedOut: null, 
 startingSlide: undefined,
 sync: 1, 
 timeout: 4000, 
 timeoutFn: null, 
 updateActivePagerLink: null,
 width: null 
};
})(jQuery);

(function($) {
"use strict";





$.fn.cycle.transitions.none = function($cont, $slides, opts) {
opts.fxFn = function(curr,next,opts,after){
$(next).show();
$(curr).hide();
after();
};
};

$.fn.cycle.transitions.fadeout = function($cont, $slides, opts) {
$slides.not(':eq('+opts.currSlide+')').css({ display: 'block', 'opacity': 1 });
opts.before.push(function(curr,next,opts,w,h,rev) {
$(curr).css('zIndex',opts.slideCount + (rev !== true ? 1 : 0));
$(next).css('zIndex',opts.slideCount + (rev !== true ? 0 : 1));
});
opts.animIn.opacity = 1;
opts.animOut.opacity = 0;
opts.cssBefore.opacity = 1;
opts.cssBefore.display = 'block';
opts.cssAfter.zIndex = 0;
};

$.fn.cycle.transitions.scrollUp = function($cont, $slides, opts) {
$cont.css('overflow','hidden');
opts.before.push($.fn.cycle.commonReset);
var h = $cont.height();
opts.cssBefore.top = h;
opts.cssBefore.left = 0;
opts.cssFirst.top = 0;
opts.animIn.top = 0;
opts.animOut.top = -h;
};
$.fn.cycle.transitions.scrollDown = function($cont, $slides, opts) {
$cont.css('overflow','hidden');
opts.before.push($.fn.cycle.commonReset);
var h = $cont.height();
opts.cssFirst.top = 0;
opts.cssBefore.top = -h;
opts.cssBefore.left = 0;
opts.animIn.top = 0;
opts.animOut.top = h;
};
$.fn.cycle.transitions.scrollLeft = function($cont, $slides, opts) {
$cont.css('overflow','hidden');
opts.before.push($.fn.cycle.commonReset);
var w = $cont.width();
opts.cssFirst.left = 0;
opts.cssBefore.left = w;
opts.cssBefore.top = 0;
opts.animIn.left = 0;
opts.animOut.left = 0-w;
};
$.fn.cycle.transitions.scrollRight = function($cont, $slides, opts) {
$cont.css('overflow','hidden');
opts.before.push($.fn.cycle.commonReset);
var w = $cont.width();
opts.cssFirst.left = 0;
opts.cssBefore.left = -w;
opts.cssBefore.top = 0;
opts.animIn.left = 0;
opts.animOut.left = w;
};
$.fn.cycle.transitions.scrollHorz = function($cont, $slides, opts) {
$cont.css('overflow','hidden').width();
opts.before.push(function(curr, next, opts, fwd) {
if (opts.rev)
fwd = !fwd;
$.fn.cycle.commonReset(curr,next,opts);
opts.cssBefore.left = fwd ? (next.cycleW-1) : (1-next.cycleW);
opts.animOut.left = fwd ? -curr.cycleW : curr.cycleW;
});
opts.cssFirst.left = 0;
opts.cssBefore.top = 0;
opts.animIn.left = 0;
opts.animOut.top = 0;
};
$.fn.cycle.transitions.scrollVert = function($cont, $slides, opts) {
$cont.css('overflow','hidden');
opts.before.push(function(curr, next, opts, fwd) {
if (opts.rev)
fwd = !fwd;
$.fn.cycle.commonReset(curr,next,opts);
opts.cssBefore.top = fwd ? (1-next.cycleH) : (next.cycleH-1);
opts.animOut.top = fwd ? curr.cycleH : -curr.cycleH;
});
opts.cssFirst.top = 0;
opts.cssBefore.left = 0;
opts.animIn.top = 0;
opts.animOut.left = 0;
};

$.fn.cycle.transitions.slideX = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$(opts.elements).not(curr).hide();
$.fn.cycle.commonReset(curr,next,opts,false,true);
opts.animIn.width = next.cycleW;
});
opts.cssBefore.left = 0;
opts.cssBefore.top = 0;
opts.cssBefore.width = 0;
opts.animIn.width = 'show';
opts.animOut.width = 0;
};
$.fn.cycle.transitions.slideY = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$(opts.elements).not(curr).hide();
$.fn.cycle.commonReset(curr,next,opts,true,false);
opts.animIn.height = next.cycleH;
});
opts.cssBefore.left = 0;
opts.cssBefore.top = 0;
opts.cssBefore.height = 0;
opts.animIn.height = 'show';
opts.animOut.height = 0;
};

$.fn.cycle.transitions.shuffle = function($cont, $slides, opts) {
var i, w = $cont.css('overflow', 'visible').width();
$slides.css({left: 0, top: 0});
opts.before.push(function(curr,next,opts) {
$.fn.cycle.commonReset(curr,next,opts,true,true,true);
});

	if (!opts.speedAdjusted) {
opts.speed = opts.speed / 2; 
 opts.speedAdjusted = true;
}
opts.random = 0;
opts.shuffle = opts.shuffle || {left:-w, top:15};
opts.els = [];
for (i=0; i < $slides.length; i++)
opts.els.push($slides[i]);
for (i=0; i < opts.currSlide; i++)
opts.els.push(opts.els.shift());

	opts.fxFn = function(curr, next, opts, cb, fwd) {
if (opts.rev)
fwd = !fwd;
var $el = fwd ? $(curr) : $(next);
$(next).css(opts.cssBefore);
var count = opts.slideCount;
$el.animate(opts.shuffle, opts.speedIn, opts.easeIn, function() {
var hops = $.fn.cycle.hopsFromLast(opts, fwd);
for (var k=0; k < hops; k++) {
if (fwd)
opts.els.push(opts.els.shift());
else
opts.els.unshift(opts.els.pop());
}
if (fwd) {
for (var i=0, len=opts.els.length; i < len; i++)
$(opts.els[i]).css('z-index', len-i+count);
}
else {
var z = $(curr).css('z-index');
$el.css('z-index', parseInt(z,10)+1+count);
}
$el.animate({left:0, top:0}, opts.speedOut, opts.easeOut, function() {
$(fwd ? this : curr).hide();
if (cb) cb();
});
});
};
$.extend(opts.cssBefore, { display: 'block', opacity: 1, top: 0, left: 0 });
};

$.fn.cycle.transitions.turnUp = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,false);
opts.cssBefore.top = next.cycleH;
opts.animIn.height = next.cycleH;
opts.animOut.width = next.cycleW;
});
opts.cssFirst.top = 0;
opts.cssBefore.left = 0;
opts.cssBefore.height = 0;
opts.animIn.top = 0;
opts.animOut.height = 0;
};
$.fn.cycle.transitions.turnDown = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,false);
opts.animIn.height = next.cycleH;
opts.animOut.top = curr.cycleH;
});
opts.cssFirst.top = 0;
opts.cssBefore.left = 0;
opts.cssBefore.top = 0;
opts.cssBefore.height = 0;
opts.animOut.height = 0;
};
$.fn.cycle.transitions.turnLeft = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,true);
opts.cssBefore.left = next.cycleW;
opts.animIn.width = next.cycleW;
});
opts.cssBefore.top = 0;
opts.cssBefore.width = 0;
opts.animIn.left = 0;
opts.animOut.width = 0;
};
$.fn.cycle.transitions.turnRight = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,true);
opts.animIn.width = next.cycleW;
opts.animOut.left = curr.cycleW;
});
$.extend(opts.cssBefore, { top: 0, left: 0, width: 0 });
opts.animIn.left = 0;
opts.animOut.width = 0;
};

$.fn.cycle.transitions.zoom = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,false,true);
opts.cssBefore.top = next.cycleH/2;
opts.cssBefore.left = next.cycleW/2;
$.extend(opts.animIn, { top: 0, left: 0, width: next.cycleW, height: next.cycleH });
$.extend(opts.animOut, { width: 0, height: 0, top: curr.cycleH/2, left: curr.cycleW/2 });
});
opts.cssFirst.top = 0;
opts.cssFirst.left = 0;
opts.cssBefore.width = 0;
opts.cssBefore.height = 0;
};

$.fn.cycle.transitions.fadeZoom = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,false);
opts.cssBefore.left = next.cycleW/2;
opts.cssBefore.top = next.cycleH/2;
$.extend(opts.animIn, { top: 0, left: 0, width: next.cycleW, height: next.cycleH });
});
opts.cssBefore.width = 0;
opts.cssBefore.height = 0;
opts.animOut.opacity = 0;
};

$.fn.cycle.transitions.blindX = function($cont, $slides, opts) {
var w = $cont.css('overflow','hidden').width();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts);
opts.animIn.width = next.cycleW;
opts.animOut.left = curr.cycleW;
});
opts.cssBefore.left = w;
opts.cssBefore.top = 0;
opts.animIn.left = 0;
opts.animOut.left = w;
};

$.fn.cycle.transitions.blindY = function($cont, $slides, opts) {
var h = $cont.css('overflow','hidden').height();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts);
opts.animIn.height = next.cycleH;
opts.animOut.top = curr.cycleH;
});
opts.cssBefore.top = h;
opts.cssBefore.left = 0;
opts.animIn.top = 0;
opts.animOut.top = h;
};

$.fn.cycle.transitions.blindZ = function($cont, $slides, opts) {
var h = $cont.css('overflow','hidden').height();
var w = $cont.width();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts);
opts.animIn.height = next.cycleH;
opts.animOut.top = curr.cycleH;
});
opts.cssBefore.top = h;
opts.cssBefore.left = w;
opts.animIn.top = 0;
opts.animIn.left = 0;
opts.animOut.top = h;
opts.animOut.left = w;
};

$.fn.cycle.transitions.growX = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,true);
opts.cssBefore.left = this.cycleW/2;
opts.animIn.left = 0;
opts.animIn.width = this.cycleW;
opts.animOut.left = 0;
});
opts.cssBefore.top = 0;
opts.cssBefore.width = 0;
};

$.fn.cycle.transitions.growY = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,false);
opts.cssBefore.top = this.cycleH/2;
opts.animIn.top = 0;
opts.animIn.height = this.cycleH;
opts.animOut.top = 0;
});
opts.cssBefore.height = 0;
opts.cssBefore.left = 0;
};

$.fn.cycle.transitions.curtainX = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,false,true,true);
opts.cssBefore.left = next.cycleW/2;
opts.animIn.left = 0;
opts.animIn.width = this.cycleW;
opts.animOut.left = curr.cycleW/2;
opts.animOut.width = 0;
});
opts.cssBefore.top = 0;
opts.cssBefore.width = 0;
};

$.fn.cycle.transitions.curtainY = function($cont, $slides, opts) {
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,false,true);
opts.cssBefore.top = next.cycleH/2;
opts.animIn.top = 0;
opts.animIn.height = next.cycleH;
opts.animOut.top = curr.cycleH/2;
opts.animOut.height = 0;
});
opts.cssBefore.height = 0;
opts.cssBefore.left = 0;
};

$.fn.cycle.transitions.cover = function($cont, $slides, opts) {
var d = opts.direction || 'left';
var w = $cont.css('overflow','hidden').width();
var h = $cont.height();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts);
if (d == 'right')
opts.cssBefore.left = -w;
else if (d == 'up')
opts.cssBefore.top = h;
else if (d == 'down')
opts.cssBefore.top = -h;
else
opts.cssBefore.left = w;
});
opts.animIn.left = 0;
opts.animIn.top = 0;
opts.cssBefore.top = 0;
opts.cssBefore.left = 0;
};

$.fn.cycle.transitions.uncover = function($cont, $slides, opts) {
var d = opts.direction || 'left';
var w = $cont.css('overflow','hidden').width();
var h = $cont.height();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,true,true);
if (d == 'right')
opts.animOut.left = w;
else if (d == 'up')
opts.animOut.top = -h;
else if (d == 'down')
opts.animOut.top = h;
else
opts.animOut.left = -w;
});
opts.animIn.left = 0;
opts.animIn.top = 0;
opts.cssBefore.top = 0;
opts.cssBefore.left = 0;
};

$.fn.cycle.transitions.toss = function($cont, $slides, opts) {
var w = $cont.css('overflow','visible').width();
var h = $cont.height();
opts.before.push(function(curr, next, opts) {
$.fn.cycle.commonReset(curr,next,opts,true,true,true);

 if (!opts.animOut.left && !opts.animOut.top)
$.extend(opts.animOut, { left: w*2, top: -h/2, opacity: 0 });
else
opts.animOut.opacity = 0;
});
opts.cssBefore.left = 0;
opts.cssBefore.top = 0;
opts.animIn.left = 0;
};

$.fn.cycle.transitions.wipe = function($cont, $slides, opts) {
var w = $cont.css('overflow','hidden').width();
var h = $cont.height();
opts.cssBefore = opts.cssBefore || {};
var clip;
if (opts.clip) {
if (/l2r/.test(opts.clip))
clip = 'rect(0px 0px '+h+'px 0px)';
else if (/r2l/.test(opts.clip))
clip = 'rect(0px '+w+'px '+h+'px '+w+'px)';
else if (/t2b/.test(opts.clip))
clip = 'rect(0px '+w+'px 0px 0px)';
else if (/b2t/.test(opts.clip))
clip = 'rect('+h+'px '+w+'px '+h+'px 0px)';
else if (/zoom/.test(opts.clip)) {
var top = parseInt(h/2,10);
var left = parseInt(w/2,10);
clip = 'rect('+top+'px '+left+'px '+top+'px '+left+'px)';
}
}
opts.cssBefore.clip = opts.cssBefore.clip || clip || 'rect(0px 0px 0px 0px)';
var d = opts.cssBefore.clip.match(/(\d+)/g);
var t = parseInt(d[0],10), r = parseInt(d[1],10), b = parseInt(d[2],10), l = parseInt(d[3],10);
opts.before.push(function(curr, next, opts) {
if (curr == next) return;
var $curr = $(curr), $next = $(next);
$.fn.cycle.commonReset(curr,next,opts,true,true,false);
opts.cssAfter.display = 'block';
var step = 1, count = parseInt((opts.speedIn / 13),10) - 1;
(function f() {
var tt = t ? t - parseInt(step * (t/count),10) : 0;
var ll = l ? l - parseInt(step * (l/count),10) : 0;
var bb = b < h ? b + parseInt(step * ((h-b)/count || 1),10) : h;
var rr = r < w ? r + parseInt(step * ((w-r)/count || 1),10) : w;
$next.css({ clip: 'rect('+tt+'px '+rr+'px '+bb+'px '+ll+'px)' });
(step++ <= count) ? setTimeout(f, 13) : $curr.css('display', 'none');
})();
});
$.extend(opts.cssBefore, { display: 'block', opacity: 1, top: 0, left: 0 });
opts.animIn = { left: 0 };
opts.animOut = { left: 0 };
};
})(jQuery);


(function($) {
$.fn.touchwipe = function(settings) {
var config = {
min_move_x: 20,
min_move_y: 20,
wipeLeft: function(e) { },
wipeRight: function(e) { },
wipeUp: function(e) { },
wipeDown: function(e) { },
preventDefaultEvents: true
};
if (settings) $.extend(config, settings);
this.each(function() {
var startX;
var startY;
var isMoving = false;
function cancelTouch() {
this.removeEventListener('touchmove', onTouchMove);
startX = null;
isMoving = false;
}
function onTouchMove(e) {
if(config.preventDefaultEvents) {
e.preventDefault();
}
if(isMoving) {
var x = e.touches[0].pageX;
var y = e.touches[0].pageY;
var dx = startX - x;
var dy = startY - y;
if(Math.abs(dx) >= config.min_move_x) {
cancelTouch();
if(dx > 0) {
config.wipeLeft(e);
}
else {
config.wipeRight(e);
}
}
else if(Math.abs(dy) >= config.min_move_y) {
cancelTouch();
if(dy > 0) {
config.wipeDown(e);
}
else {
config.wipeUp(e);
}
}
}
}
function onTouchStart(e)
{
if (e.touches.length == 1) {
startX = e.touches[0].pageX;
startY = e.touches[0].pageY;
isMoving = true;
this.addEventListener('touchmove', onTouchMove, false);
}
}
if ('ontouchstart' in document.documentElement) {
this.addEventListener('touchstart', onTouchStart, false);
}
});
return this;
};
})(jQuery);




(function ($) {

 
 $.caretTo = function (el, index) {
if (el.createTextRange) {
var range = el.createTextRange();
range.move("character", index);
range.select();
} else if (el.selectionStart != null) {
el.focus();
el.setSelectionRange(index, index);
}
};

 
 
 


















 $.fn.caretTo = function (index, offset) {
return this.queue(function (next) {
if (isNaN(index)) {
var i = $(this).val().indexOf(index);
if (offset === true) {
i += index.length;
} else if (offset) {
i += offset;
}
$.caretTo(this, i);
} else {
$.caretTo(this, index);
}
next();
});
};

 $.fn.caretToStart = function () {
return this.caretTo(0);
};

 $.fn.caretToEnd = function () {
return this.queue(function (next) {
$.caretTo(this, $(this).val().length);
next();
});
};
}(jQuery));

this.org = this.org || {};
org.cometd = {};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value)
{
if (value === undefined || value === null)
{
return false;
}
return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value)
{
if (value === undefined || value === null)
{
return false;
}
return value instanceof Array;
};

org.cometd.Utils.inArray = function(element, array)
{
for (var i = 0; i < array.length; ++i)
{
if (element === array[i])
{
return i;
}
}
return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay)
{
return window.setTimeout(function()
{
try
{
cometd._debug('Invoking timed function', funktion);
funktion();
}
catch (x)
{
cometd._debug('Exception invoking timed function', funktion, x);
}
}, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle)
{
window.clearTimeout(timeoutHandle);
};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object)
{
throw 'Abstract';
};

org.cometd.TransportRegistry = function()
{
var _types = [];
var _transports = {};
this.getTransportTypes = function()
{
return _types.slice(0);
};
this.findTransportTypes = function(version, crossDomain, url)
{
var result = [];
for (var i = 0; i < _types.length; ++i)
{
var type = _types[i];
if (_transports[type].accept(version, crossDomain, url) === true)
{
result.push(type);
}
}
return result;
};
this.negotiateTransport = function(types, version, crossDomain, url)
{
for (var i = 0; i < _types.length; ++i)
{
var type = _types[i];
for (var j = 0; j < types.length; ++j)
{
if (type === types[j])
{
var transport = _transports[type];
if (transport.accept(version, crossDomain, url) === true)
{
return transport;
}
}
}
}
return null;
};
this.add = function(type, transport, index)
{
var existing = false;
for (var i = 0; i < _types.length; ++i)
{
if (_types[i] === type)
{
existing = true;
break;
}
}
if (!existing)
{
if (typeof index !== 'number')
{
_types.push(type);
}
else
{
_types.splice(index, 0, type);
}
_transports[type] = transport;
}
return !existing;
};
this.find = function(type)
{
for (var i = 0; i < _types.length; ++i)
{
if (_types[i] === type)
{
return _transports[type];
}
}
return null;
};
this.remove = function(type)
{
for (var i = 0; i < _types.length; ++i)
{
if (_types[i] === type)
{
_types.splice(i, 1);
var transport = _transports[type];
delete _transports[type];
return transport;
}
}
return null;
};
this.clear = function()
{
_types = [];
_transports = {};
};
this.reset = function()
{
for (var i = 0; i < _types.length; ++i)
{
_transports[_types[i]].reset();
}
};
};

org.cometd.Transport = function()
{
var _type;
var _cometd;

this.registered = function(type, cometd)
{
_type = type;
_cometd = cometd;
};

this.unregistered = function()
{
_type = null;
_cometd = null;
};
this._debug = function()
{
_cometd._debug.apply(_cometd, arguments);
};
this._mixin = function()
{
return _cometd._mixin.apply(_cometd, arguments);
};
this.getConfiguration = function()
{
return _cometd.getConfiguration();
};
this.getAdvice = function()
{
return _cometd.getAdvice();
};
this.setTimeout = function(funktion, delay)
{
return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
};
this.clearTimeout = function(handle)
{
org.cometd.Utils.clearTimeout(handle);
};

this.convertToMessages = function (response)
{
if (org.cometd.Utils.isString(response))
{
try
{
return org.cometd.JSON.fromJSON(response);
}
catch(x)
{
this._debug('Could not convert to JSON the following string', '"' + response + '"');
throw x;
}
}
if (org.cometd.Utils.isArray(response))
{
return response;
}
if (response === undefined || response === null)
{
return [];
}
if (response instanceof Object)
{
return [response];
}
throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
};

this.accept = function(version, crossDomain, url)
{
throw 'Abstract';
};

this.getType = function()
{
return _type;
};
this.send = function(envelope, metaConnect)
{
throw 'Abstract';
};
this.reset = function()
{
this._debug('Transport', _type, 'reset');
};
this.abort = function()
{
this._debug('Transport', _type, 'aborted');
};
this.toString = function()
{
return this.getType();
};
};
org.cometd.Transport.derive = function(baseObject)
{
function F() {}
F.prototype = baseObject;
return new F();
};
org.cometd.WebSocketTransport = function()
{
var _super = new org.cometd.Transport();
var _self = org.cometd.Transport.derive(_super);
var _cometd;

 var _webSocketSupported = true;

 var _webSocketConnected = false;
var _stickyReconnect = true;

 var _envelopes = {};

 var _timeouts = {};
var _connecting = false;
var _webSocket = null;
var _connected = false;
var _successCallback = null;
_self.reset = function()
{
_super.reset();
_webSocketSupported = true;
_webSocketConnected = false;
_stickyReconnect = true;
_envelopes = {};
_timeouts = {};
_connecting = false;
_connected = false;
};
function _websocketConnect()
{

 
 
 
 if (_connecting)
{
return;
}
_connecting = true;

 var url = _cometd.getURL().replace(/^http/, 'ws');
this._debug('Transport', this.getType(), 'connecting to URL', url);
var webSocket;
try
{
var protocol = _cometd.getConfiguration().protocol;
webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
}
catch (x)
{
_webSocketSupported = false;
this._debug('Exception while creating WebSocket object', x);
throw x;
}

 _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
var self = this;
var connectTimer = null;
var connectTimeout = _cometd.getConfiguration().connectTimeout;
if (connectTimeout > 0)
{
connectTimer = this.setTimeout(function()
{
connectTimer = null;
self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');

 var event = { code: 1000, reason: 'Connect Timeout' };
self.webSocketClose(webSocket, event.code, event.reason);

 
 
 self.onClose(webSocket, event);
}, connectTimeout);
}
var onopen = function()
{
self._debug('WebSocket opened', webSocket);
_connecting = false;
if (connectTimer)
{
self.clearTimeout(connectTimer);
connectTimer = null;
}
if (_webSocket)
{

 _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);

 
 self.webSocketClose(webSocket, 1000, 'Extra Connection');
}
else
{
self.onOpen(webSocket);
}
};

 var onclose = function(event)
{
event = event || { code: 1000 };
self._debug('WebSocket closing', webSocket, event);
_connecting = false;
if (connectTimer)
{
self.clearTimeout(connectTimer);
connectTimer = null;
}
if (_webSocket !== null && webSocket !== _webSocket)
{

 
 self._debug('Closed Extra WebSocket Connection', webSocket);
}
else
{
self.onClose(webSocket, event);
}
};
var onmessage = function(message)
{
self._debug('WebSocket message', message, webSocket);
if (webSocket !== _webSocket)
{
_cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
}
self.onMessage(webSocket, message);
};
webSocket.onopen = onopen;
webSocket.onclose = onclose;
webSocket.onerror = function()
{

 onclose({ code: 1002, reason: 'Error' });
};
webSocket.onmessage = onmessage;
this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
}
function _webSocketSend(webSocket, envelope, metaConnect)
{
var json = org.cometd.JSON.toJSON(envelope.messages);
webSocket.send(json);
this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);

 var maxDelay = this.getConfiguration().maxNetworkDelay;
var delay = maxDelay;
if (metaConnect)
{
delay += this.getAdvice().timeout;
_connected = true;
}
var self = this;
var messageIds = [];
for (var i = 0; i < envelope.messages.length; ++i)
{
(function()
{
var message = envelope.messages[i];
if (message.id)
{
messageIds.push(message.id);
_timeouts[message.id] = this.setTimeout(function()
{
self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
var event = { code: 1000, reason: 'Message Timeout' };
self.webSocketClose(webSocket, event.code, event.reason);

 
 
 self.onClose(webSocket, event);
}, delay);
}
})();
}
this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
}
function _send(webSocket, envelope, metaConnect)
{
try
{
if (webSocket === null)
{
_websocketConnect.call(this);
}
else
{
_webSocketSend.call(this, webSocket, envelope, metaConnect);
}
}
catch (x)
{

 this.setTimeout(function()
{
envelope.onFailure(webSocket, envelope.messages, {
exception: x
});
}, 0);
}
}
_self.onOpen = function(webSocket)
{
this._debug('Transport', this.getType(), 'opened', webSocket);
_webSocket = webSocket;
_webSocketConnected = true;
this._debug('Sending pending messages', _envelopes);
for (var key in _envelopes)
{
var element = _envelopes[key];
var envelope = element[0];
var metaConnect = element[1];

 
 _successCallback = envelope.onSuccess;
_webSocketSend.call(this, webSocket, envelope, metaConnect);
}
};
_self.onMessage = function(webSocket, wsMessage)
{
this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
var close = false;
var messages = this.convertToMessages(wsMessage.data);
var messageIds = [];
for (var i = 0; i < messages.length; ++i)
{
var message = messages[i];

 
 
 if (/^\/meta\//.test(message.channel) || message.data === undefined)
{
if (message.id)
{
messageIds.push(message.id);
var timeout = _timeouts[message.id];
if (timeout)
{
this.clearTimeout(timeout);
delete _timeouts[message.id];
this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
}
}
}
if ('/meta/connect' === message.channel)
{
_connected = false;
}
if ('/meta/disconnect' === message.channel && !_connected)
{
close = true;
}
}

 var removed = false;
for (var j = 0; j < messageIds.length; ++j)
{
var id = messageIds[j];
for (var key in _envelopes)
{
var ids = key.split(',');
var index = org.cometd.Utils.inArray(id, ids);
if (index >= 0)
{
removed = true;
ids.splice(index, 1);
var envelope = _envelopes[key][0];
var metaConnect = _envelopes[key][1];
delete _envelopes[key];
if (ids.length > 0)
{
_envelopes[ids.join(',')] = [envelope, metaConnect];
}
break;
}
}
}
if (removed)
{
this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
}
_successCallback.call(this, messages);
if (close)
{
this.webSocketClose(webSocket, 1000, 'Disconnect');
}
};
_self.onClose = function(webSocket, event)
{
this._debug('Transport', this.getType(), 'closed', webSocket, event);

 
 
 _webSocketSupported = _stickyReconnect && _webSocketConnected;
var timeouts = _timeouts;
_timeouts = {};
for (var id in timeouts)
{
this.clearTimeout(timeouts[id]);
}
var envelopes = _envelopes;
_envelopes = {};
for (var key in envelopes)
{
var envelope = envelopes[key][0];
var metaConnect = envelopes[key][1];
if (metaConnect)
{
_connected = false;
}
envelope.onFailure(webSocket, envelope.messages, {
websocketCode: event.code,
reason: event.reason
});
}
_webSocket = null;
};
_self.registered = function(type, cometd)
{
_super.registered(type, cometd);
_cometd = cometd;
};
_self.accept = function(version, crossDomain, url)
{

 return _webSocketSupported && !!org.cometd.WebSocket && _cometd.websocketEnabled !== false;
};
_self.send = function(envelope, metaConnect)
{
this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);

 var messageIds = [];
for (var i = 0; i < envelope.messages.length; ++i)
{
var message = envelope.messages[i];
if (message.id)
{
messageIds.push(message.id);
}
}
_envelopes[messageIds.join(',')] = [envelope, metaConnect];
this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
_send.call(this, _webSocket, envelope, metaConnect);
};
_self.webSocketClose = function(webSocket, code, reason)
{
try
{
webSocket.close(code, reason);
}
catch (x)
{
this._debug(x);
}
};
_self.abort = function()
{
_super.abort();
if (_webSocket)
{
var event = { code: 1001, reason: 'Abort' };
this.webSocketClose(_webSocket, event.code, event.reason);

 
 
 this.onClose(_webSocket, event);
}
this.reset();
};
return _self;
};
org.cometd.LongPollingTransport = function()
{
var _super = new org.cometd.RequestTransport();
var _self = org.cometd.Transport.derive(_super);

 var _supportsCrossDomain = true;
_self.accept = function(version, crossDomain, url)
{
return _supportsCrossDomain || !crossDomain;
};
_self.xhrSend = function(packet)
{
throw 'Abstract';
};
_self.transportSend = function(envelope, request)
{
this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
var self = this;
try
{
var sameStack = true;
request.xhr = this.xhrSend({
transport: this,
url: envelope.url,
sync: envelope.sync,
headers: this.getConfiguration().requestHeaders,
body: org.cometd.JSON.toJSON(envelope.messages),
onSuccess: function(response)
{
self._debug('Transport', self.getType(), 'received response', response);
var success = false;
try
{
var received = self.convertToMessages(response);
if (received.length === 0)
{
_supportsCrossDomain = false;
self.transportFailure(envelope, request, {
httpCode: 204
});
}
else
{
success = true;
self.transportSuccess(envelope, request, received);
}
}
catch(x)
{
self._debug(x);
if (!success)
{
_supportsCrossDomain = false;
var failure = {
exception: x
};
failure.httpCode = self.xhrStatus(request.xhr);
self.transportFailure(envelope, request, failure);
}
}
},
onError: function(reason, exception)
{
self._debug('Transport', self.getType(), 'received error', reason, exception);
_supportsCrossDomain = false;
var failure = {
reason: reason,
exception: exception
};
failure.httpCode = self.xhrStatus(request.xhr);
if (sameStack)
{

 self.setTimeout(function()
{
self.transportFailure(envelope, request, failure);
}, 0);
}
else
{
self.transportFailure(envelope, request, failure);
}
}
});
sameStack = false;
}
catch (x)
{
_supportsCrossDomain = false;

 this.setTimeout(function()
{
self.transportFailure(envelope, request, {
exception: x
});
}, 0);
}
};
_self.reset = function()
{
_super.reset();
_supportsCrossDomain = true;
};
return _self;
};

org.cometd.RequestTransport = function()
{
var _super = new org.cometd.Transport();
var _self = org.cometd.Transport.derive(_super);
var _requestIds = 0;
var _metaConnectRequest = null;
var _requests = [];
var _envelopes = [];
function _coalesceEnvelopes(envelope)
{
while (_envelopes.length > 0)
{
var envelopeAndRequest = _envelopes[0];
var newEnvelope = envelopeAndRequest[0];
var newRequest = envelopeAndRequest[1];
if (newEnvelope.url === envelope.url &&
newEnvelope.sync === envelope.sync)
{
_envelopes.shift();
envelope.messages = envelope.messages.concat(newEnvelope.messages);
this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
continue;
}
break;
}
}
function _transportSend(envelope, request)
{
this.transportSend(envelope, request);
request.expired = false;
if (!envelope.sync)
{
var maxDelay = this.getConfiguration().maxNetworkDelay;
var delay = maxDelay;
if (request.metaConnect === true)
{
delay += this.getAdvice().timeout;
}
this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
var self = this;
request.timeout = this.setTimeout(function()
{
request.expired = true;
var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
var failure = {
reason: errorMessage
};
var xhr = request.xhr;
failure.httpCode = self.xhrStatus(xhr);
self.abortXHR(xhr);
self._debug(errorMessage);
self.complete(request, false, request.metaConnect);
envelope.onFailure(xhr, envelope.messages, failure);
}, delay);
}
}
function _queueSend(envelope)
{
var requestId = ++_requestIds;
var request = {
id: requestId,
metaConnect: false,
envelope: envelope
};

 if (_requests.length < this.getConfiguration().maxConnections - 1)
{
_requests.push(request);
_transportSend.call(this, envelope, request);
}
else
{
this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
_envelopes.push([envelope, request]);
}
}
function _metaConnectComplete(request)
{
var requestId = request.id;
this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId)
{
throw 'Longpoll request mismatch, completing request ' + requestId;
}

 _metaConnectRequest = null;
}
function _complete(request, success)
{
var index = org.cometd.Utils.inArray(request, _requests);

 if (index >= 0)
{
_requests.splice(index, 1);
}
if (_envelopes.length > 0)
{
var envelopeAndRequest = _envelopes.shift();
var nextEnvelope = envelopeAndRequest[0];
var nextRequest = envelopeAndRequest[1];
this._debug('Transport dequeued request', nextRequest.id);
if (success)
{
if (this.getConfiguration().autoBatch)
{
_coalesceEnvelopes.call(this, nextEnvelope);
}
_queueSend.call(this, nextEnvelope);
this._debug('Transport completed request', request.id, nextEnvelope);
}
else
{

 var self = this;
this.setTimeout(function()
{
self.complete(nextRequest, false, nextRequest.metaConnect);
var failure = {
reason: 'Previous request failed'
};
var xhr = nextRequest.xhr;
failure.httpCode = self.xhrStatus(xhr);
nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
}, 0);
}
}
}
_self.complete = function(request, success, metaConnect)
{
if (metaConnect)
{
_metaConnectComplete.call(this, request);
}
else
{
_complete.call(this, request, success);
}
};

_self.transportSend = function(envelope, request)
{
throw 'Abstract';
};
_self.transportSuccess = function(envelope, request, responses)
{
if (!request.expired)
{
this.clearTimeout(request.timeout);
this.complete(request, true, request.metaConnect);
if (responses && responses.length > 0)
{
envelope.onSuccess(responses);
}
else
{
envelope.onFailure(request.xhr, envelope.messages, {
httpCode: 204
});
}
}
};
_self.transportFailure = function(envelope, request, failure)
{
if (!request.expired)
{
this.clearTimeout(request.timeout);
this.complete(request, false, request.metaConnect);
envelope.onFailure(request.xhr, envelope.messages, failure);
}
};
function _metaConnectSend(envelope)
{
if (_metaConnectRequest !== null)
{
throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
}
var requestId = ++_requestIds;
this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
var request = {
id: requestId,
metaConnect: true,
envelope: envelope
};
_transportSend.call(this, envelope, request);
_metaConnectRequest = request;
}
_self.send = function(envelope, metaConnect)
{
if (metaConnect)
{
_metaConnectSend.call(this, envelope);
}
else
{
_queueSend.call(this, envelope);
}
};
_self.abort = function()
{
_super.abort();
for (var i = 0; i < _requests.length; ++i)
{
var request = _requests[i];
if (request)
{
this._debug('Aborting request', request);
if (!this.abortXHR(request.xhr))
{
this.transportFailure(request.envelope, request, {reason: 'abort'});
}
}
}
if (_metaConnectRequest)
{
this._debug('Aborting metaConnect request', _metaConnectRequest);
if (!this.abortXHR(_metaConnectRequest.xhr))
{
this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});
}
}
this.reset();
};
_self.reset = function()
{
_super.reset();
_metaConnectRequest = null;
_requests = [];
_envelopes = [];
};
_self.abortXHR = function(xhr)
{
if (xhr)
{
try
{
var state = xhr.readyState;
xhr.abort();
return state !== XMLHttpRequest.UNSENT;
}
catch (x)
{
this._debug(x);
}
}
return false;
};
_self.xhrStatus = function(xhr)
{
if (xhr)
{
try
{
return xhr.status;
}
catch (x)
{
this._debug(x);
}
}
return -1;
};
return _self;
};
org.cometd.CallbackPollingTransport = function()
{
var _super = new org.cometd.RequestTransport();
var _self = org.cometd.Transport.derive(_super);
var _maxLength = 2000;
_self.accept = function(version, crossDomain, url)
{
return true;
};
_self.jsonpSend = function(packet)
{
throw 'Abstract';
};
function _failTransportFn(envelope, request, x)
{
var self = this;
return function()
{
self.transportFailure(envelope, request, 'error', x);
};
}
_self.transportSend = function(envelope, request)
{
var self = this;

 
 var start = 0;
var length = envelope.messages.length;
var lengths = [];
while (length > 0)
{

 
 var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
var urlLength = envelope.url.length + encodeURI(json).length;

 
 
 
 if (urlLength > _maxLength)
{
if (length === 1)
{
var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + _maxLength + ') ' +
'for transport ' + this.getType();

 this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);
return;
}
--length;
continue;
}
lengths.push(length);
start += length;
length = envelope.messages.length - start;
}


var envelopeToSend = envelope;
if (lengths.length > 1)
{
var begin = 0;
var end = lengths[0];
this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
envelopeToSend = this._mixin(false, {}, envelope);
envelopeToSend.messages = envelope.messages.slice(begin, end);
envelopeToSend.onSuccess = envelope.onSuccess;
envelopeToSend.onFailure = envelope.onFailure;
for (var i = 1; i < lengths.length; ++i)
{
var nextEnvelope = this._mixin(false, {}, envelope);
begin = end;
end += lengths[i];
nextEnvelope.messages = envelope.messages.slice(begin, end);
nextEnvelope.onSuccess = envelope.onSuccess;
nextEnvelope.onFailure = envelope.onFailure;
this.send(nextEnvelope, request.metaConnect);
}
}
this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
try
{
var sameStack = true;
this.jsonpSend({
transport: this,
url: envelopeToSend.url,
sync: envelopeToSend.sync,
headers: this.getConfiguration().requestHeaders,
body: org.cometd.JSON.toJSON(envelopeToSend.messages),
onSuccess: function(responses)
{
var success = false;
try
{
var received = self.convertToMessages(responses);
if (received.length === 0)
{
self.transportFailure(envelopeToSend, request, {
httpCode: 204
});
}
else
{
success = true;
self.transportSuccess(envelopeToSend, request, received);
}
}
catch (x)
{
self._debug(x);
if (!success)
{
self.transportFailure(envelopeToSend, request, {
exception: x
});
}
}
},
onError: function(reason, exception)
{
var failure = {
reason: reason,
exception: exception
};
if (sameStack)
{

 self.setTimeout(function()
{
self.transportFailure(envelopeToSend, request, failure);
}, 0);
}
else
{
self.transportFailure(envelopeToSend, request, failure);
}
}
});
sameStack = false;
}
catch (xx)
{

 this.setTimeout(function()
{
self.transportFailure(envelopeToSend, request, {
exception: xx
});
}, 0);
}
};
return _self;
};





org.cometd.CometD = function(name)
{
var _cometd = this;
var _name = name || 'default';
var _crossDomain = false;
var _transports = new org.cometd.TransportRegistry();
var _transport;
var _status = 'disconnected';
var _messageId = 0;
var _clientId = null;
var _batch = 0;
var _messageQueue = [];
var _internalBatch = false;
var _listeners = {};
var _backoff = 0;
var _scheduledSend = null;
var _extensions = [];
var _advice = {};
var _handshakeProps;
var _handshakeCallback;
var _callbacks = {};
var _remoteCalls = {};
var _reestablish = false;
var _connected = false;
var _config = {
protocol: null,
stickyReconnect: true,
connectTimeout: 0,
maxConnections: 2,
backoffIncrement: 1000,
maxBackoff: 60000,
logLevel: 'info',
reverseIncomingExtensions: true,
maxNetworkDelay: 10000,
requestHeaders: {},
appendMessageTypeToURL: true,
autoBatch: false,
advice: {
timeout: 60000,
interval: 0,
reconnect: 'retry'
}
};
function _fieldValue(object, name)
{
try
{
return object[name];
}
catch (x)
{
return undefined;
}
}

this._mixin = function(deep, target, objects)
{
var result = target || {};

 for (var i = 2; i < arguments.length; ++i)
{
var object = arguments[i];
if (object === undefined || object === null)
{
continue;
}
for (var propName in object)
{
var prop = _fieldValue(object, propName);
var targ = _fieldValue(result, propName);

 if (prop === target)
{
continue;
}

 if (prop === undefined)
{
continue;
}
if (deep && typeof prop === 'object' && prop !== null)
{
if (prop instanceof Array)
{
result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
}
else
{
var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
result[propName] = this._mixin(deep, source, prop);
}
}
else
{
result[propName] = prop;
}
}
}
return result;
};
function _isString(value)
{
return org.cometd.Utils.isString(value);
}
function _isFunction(value)
{
if (value === undefined || value === null)
{
return false;
}
return typeof value === 'function';
}
function _zeroPad(value, length)
{
var result = '';
while (--length > 0)
{
if (value >= Math.pow(10, length))
{
break;
}
result += '0';
}
result += value;
return result;
}
function _log(level, args)
{
if (window.console)
{
var logger = window.console[level];
if (_isFunction(logger))
{
var now = new Date();
[].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +
_zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
logger.apply(window.console, args);
}
}
}
this._warn = function()
{
_log('warn', arguments);
};
this._info = function()
{
if (_config.logLevel !== 'warn')
{
_log('info', arguments);
}
};
this._debug = function()
{
if (_config.logLevel === 'debug')
{
_log('debug', arguments);
}
};

this._isCrossDomain = function(hostAndPort)
{
return hostAndPort && hostAndPort !== window.location.host;
};
function _configure(configuration)
{
_cometd._debug('Configuring cometd object with', configuration);

 if (_isString(configuration))
{
configuration = { url: configuration };
}
if (!configuration)
{
configuration = {};
}
_config = _cometd._mixin(false, _config, configuration);
var url = _cometd.getURL();
if (!url)
{
throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
}

 
 var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
var hostAndPort = urlParts[2];
var uri = urlParts[8];
var afterURI = urlParts[9];
_crossDomain = _cometd._isCrossDomain(hostAndPort);

 if (_config.appendMessageTypeToURL)
{
if (afterURI !== undefined && afterURI.length > 0)
{
_cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
_config.appendMessageTypeToURL = false;
}
else
{
var uriSegments = uri.split('/');
var lastSegmentIndex = uriSegments.length - 1;
if (uri.match(/\/$/))
{
lastSegmentIndex -= 1;
}
if (uriSegments[lastSegmentIndex].indexOf('.') >= 0)
{

 
 _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
_config.appendMessageTypeToURL = false;
}
}
}
}
function _removeListener(subscription)
{
if (subscription)
{
var subscriptions = _listeners[subscription.channel];
if (subscriptions && subscriptions[subscription.id])
{
delete subscriptions[subscription.id];
_cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
}
}
}
function _removeSubscription(subscription)
{
if (subscription && !subscription.listener)
{
_removeListener(subscription);
}
}
function _clearSubscriptions()
{
for (var channel in _listeners)
{
var subscriptions = _listeners[channel];
if (subscriptions)
{
for (var i = 0; i < subscriptions.length; ++i)
{
_removeSubscription(subscriptions[i]);
}
}
}
}
function _setStatus(newStatus)
{
if (_status !== newStatus)
{
_cometd._debug('Status', _status, '->', newStatus);
_status = newStatus;
}
}
function _isDisconnected()
{
return _status === 'disconnecting' || _status === 'disconnected';
}
function _nextMessageId()
{
var result = ++_messageId;
return '' + result;
}
function _applyExtension(scope, callback, name, message, outgoing)
{
try
{
return callback.call(scope, message);
}
catch (x)
{
var handler = _cometd.onExtensionException;
if (_isFunction(handler))
{
_cometd._debug('Invoking extension exception handler', name, x);
try
{
handler.call(_cometd, x, name, outgoing, message);
}
catch(xx)
{
_cometd._info('Exception during execution of extension exception handler', name, xx);
}
}
else
{
_cometd._info('Exception during execution of extension', name, x);
}
return message;
}
}
function _applyIncomingExtensions(message)
{
for (var i = 0; i < _extensions.length; ++i)
{
if (message === undefined || message === null)
{
break;
}
var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
var extension = _extensions[index];
var callback = extension.extension.incoming;
if (_isFunction(callback))
{
var result = _applyExtension(extension.extension, callback, extension.name, message, false);
message = result === undefined ? message : result;
}
}
return message;
}
function _applyOutgoingExtensions(message)
{
for (var i = 0; i < _extensions.length; ++i)
{
if (message === undefined || message === null)
{
break;
}
var extension = _extensions[i];
var callback = extension.extension.outgoing;
if (_isFunction(callback))
{
var result = _applyExtension(extension.extension, callback, extension.name, message, true);
message = result === undefined ? message : result;
}
}
return message;
}
function _notify(channel, message)
{
var subscriptions = _listeners[channel];
if (subscriptions && subscriptions.length > 0)
{
for (var i = 0; i < subscriptions.length; ++i)
{
var subscription = subscriptions[i];

 if (subscription)
{
try
{
subscription.callback.call(subscription.scope, message);
}
catch (x)
{
var handler = _cometd.onListenerException;
if (_isFunction(handler))
{
_cometd._debug('Invoking listener exception handler', subscription, x);
try
{
handler.call(_cometd, x, subscription, subscription.listener, message);
}
catch (xx)
{
_cometd._info('Exception during execution of listener exception handler', subscription, xx);
}
}
else
{
_cometd._info('Exception during execution of listener', subscription, message, x);
}
}
}
}
}
}
function _notifyListeners(channel, message)
{

 _notify(channel, message);

 var channelParts = channel.split('/');
var last = channelParts.length - 1;
for (var i = last; i > 0; --i)
{
var channelPart = channelParts.slice(0, i).join('/') + '/*';

 
 if (i === last)
{
_notify(channelPart, message);
}

 channelPart += '*';
_notify(channelPart, message);
}
}
function _cancelDelayedSend()
{
if (_scheduledSend !== null)
{
org.cometd.Utils.clearTimeout(_scheduledSend);
}
_scheduledSend = null;
}
function _delayedSend(operation)
{
_cancelDelayedSend();
var delay = _advice.interval + _backoff;
_cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
_scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
}

 var _handleMessages;
var _handleFailure;

function _send(sync, messages, metaConnect, extraPath)
{

 
 
 
 for (var i = 0; i < messages.length; ++i)
{
var message = messages[i];
var messageId = message.id;
if (_clientId)
{
message.clientId = _clientId;
}
message = _applyOutgoingExtensions(message);
if (message !== undefined && message !== null)
{

 message.id = messageId;
messages[i] = message;
}
else
{
delete _callbacks[messageId];
messages.splice(i--, 1);
}
}
if (messages.length === 0)
{
return;
}
var url = _cometd.getURL();
if (_config.appendMessageTypeToURL)
{

 if (!url.match(/\/$/))
{
url = url + '/';
}
if (extraPath)
{
url = url + extraPath;
}
}
var envelope = {
url: url,
sync: sync,
messages: messages,
onSuccess: function(rcvdMessages)
{
try
{
_handleMessages.call(_cometd, rcvdMessages);
}
catch (x)
{
_cometd._info('Exception during handling of messages', x);
}
},
onFailure: function(conduit, messages, failure)
{
try
{
var transport = _cometd.getTransport();
failure.connectionType = transport ? transport.getType() : "unknown";
_handleFailure.call(_cometd, conduit, messages, failure);
}
catch (x)
{
_cometd._info('Exception during handling of failure', x);
}
}
};
_cometd._debug('Send', envelope);
_transport.send(envelope, metaConnect);
}
function _queueSend(message)
{
if (_batch > 0 || _internalBatch === true)
{
_messageQueue.push(message);
}
else
{
_send(false, [message], false);
}
}

this.send = _queueSend;
function _resetBackoff()
{
_backoff = 0;
}
function _increaseBackoff()
{
if (_backoff < _config.maxBackoff)
{
_backoff += _config.backoffIncrement;
}
}

function _startBatch()
{
++_batch;
_cometd._debug('Starting batch, depth', _batch);
}
function _flushBatch()
{
var messages = _messageQueue;
_messageQueue = [];
if (messages.length > 0)
{
_send(false, messages, false);
}
}

function _endBatch()
{
--_batch;
_cometd._debug('Ending batch, depth', _batch);
if (_batch < 0)
{
throw 'Calls to startBatch() and endBatch() are not paired';
}
if (_batch === 0 && !_isDisconnected() && !_internalBatch)
{
_flushBatch();
}
}

function _connect()
{
if (!_isDisconnected())
{
var bayeuxMessage = {
id: _nextMessageId(),
channel: '/meta/connect',
connectionType: _transport.getType()
};

 
 
 
 if (!_connected)
{
bayeuxMessage.advice = { timeout: 0 };
}
_setStatus('connecting');
_cometd._debug('Connect sent', bayeuxMessage);
_send(false, [bayeuxMessage], true, 'connect');
_setStatus('connected');
}
}
function _delayedConnect()
{
_setStatus('connecting');
_delayedSend(function()
{
_connect();
});
}
function _updateAdvice(newAdvice)
{
if (newAdvice)
{
_advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
_cometd._debug('New advice', _advice);
}
}
function _disconnect(abort)
{
_cancelDelayedSend();
if (abort && _transport)
{
_transport.abort();
}
_clientId = null;
_setStatus('disconnected');
_batch = 0;
_resetBackoff();
_transport = null;

 if (_messageQueue.length > 0)
{
var messages = _messageQueue;
_messageQueue = [];
_handleFailure.call(_cometd, undefined, messages, {
reason: 'Disconnected'
});
}
}
function _notifyTransportFailure(oldTransport, newTransport, failure)
{
var handler = _cometd.onTransportException;
if (_isFunction(handler))
{
_cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
try
{
handler.call(_cometd, failure, oldTransport, newTransport);
}
catch (x)
{
_cometd._info('Exception during execution of transport exception handler', x);
}
}
}

function _handshake(handshakeProps, handshakeCallback)
{
if (_isFunction(handshakeProps))
{
handshakeCallback = handshakeProps;
handshakeProps = undefined;
}
_clientId = null;
_clearSubscriptions();

 if (_isDisconnected())
{
_transports.reset();
_updateAdvice(_config.advice);
}
else
{

 
 
 
 _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));
}
_batch = 0;

 
 
 
 
 
 
 _internalBatch = true;

 
 _handshakeProps = handshakeProps;
_handshakeCallback = handshakeCallback;
var version = '1.0';

 var url = _cometd.getURL();
var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
var bayeuxMessage = {
id: _nextMessageId(),
version: version,
minimumVersion: version,
channel: '/meta/handshake',
supportedConnectionTypes: transportTypes,
advice: {
timeout: _advice.timeout,
interval: _advice.interval
}
};

 var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);

 _cometd._putCallback(message.id, handshakeCallback);

 
 if (!_transport)
{
_transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
if (!_transport)
{
var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
_cometd._warn(failure);
throw failure;
}
}
_cometd._debug('Initial transport is', _transport.getType());

 
 _setStatus('handshaking');
_cometd._debug('Handshake sent', message);
_send(false, [message], false, 'handshake');
}
function _delayedHandshake()
{
_setStatus('handshaking');

 
 
 _internalBatch = true;
_delayedSend(function()
{
_handshake(_handshakeProps, _handshakeCallback);
});
}
function _notifyCallback(callback, message)
{
try
{
callback.call(_cometd, message);
}
catch (x)
{
var handler = _cometd.onCallbackException;
if (_isFunction(handler))
{
_cometd._debug('Invoking callback exception handler', x);
try
{
handler.call(_cometd, x, message);
}
catch (xx)
{
_cometd._info('Exception during execution of callback exception handler', xx);
}
}
else
{
_cometd._info('Exception during execution of message callback', x);
}
}
}
this._getCallback = function(messageId)
{
return _callbacks[messageId];
};
this._putCallback = function(messageId, callback)
{
var result = this._getCallback(messageId);
if (_isFunction(callback))
{
_callbacks[messageId] = callback;
}
return result;
};
function _handleCallback(message)
{
var callback = _cometd._getCallback([message.id]);
if (_isFunction(callback))
{
delete _callbacks[message.id];
_notifyCallback(callback, message);
}
}
function _handleRemoteCall(message)
{
var context = _remoteCalls[message.id];
delete _remoteCalls[message.id];
_cometd._debug('Handling remote call response for', message, 'with context', context);
if (context)
{

 var timeout = context.timeout;
if (timeout)
{
org.cometd.Utils.clearTimeout(timeout);
}
var callback = context.callback;
if (_isFunction(callback))
{
_notifyCallback(callback, message);
return true;
}
}
return false;
}
function _failHandshake(message)
{
_handleCallback(message);
_notifyListeners('/meta/handshake', message);
_notifyListeners('/meta/unsuccessful', message);

 
 var retry = !_isDisconnected() && _advice.reconnect !== 'none';
if (retry)
{
_increaseBackoff();
_delayedHandshake();
}
else
{
_disconnect(true);
}
}
function _handshakeResponse(message)
{
if (message.successful)
{

 _clientId = message.clientId;
var url = _cometd.getURL();
var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
if (newTransport === null)
{
var failure = 'Could not negotiate transport with server; client=[' +
_transports.findTransportTypes(message.version, _crossDomain, url) +
'], server=[' + message.supportedConnectionTypes + ']';
var oldTransport = _cometd.getTransport();
_notifyTransportFailure(oldTransport.getType(), null, {
reason: failure,
connectionType: oldTransport.getType(),
transport: oldTransport
});
_cometd._warn(failure);
_disconnect(true);
return;
}
else if (_transport !== newTransport)
{
_cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
_transport = newTransport;
}

 
 _internalBatch = false;
_flushBatch();

 
 
 message.reestablish = _reestablish;
_reestablish = true;
_handleCallback(message);
_notifyListeners('/meta/handshake', message);
var action = _isDisconnected() ? 'none' : _advice.reconnect;
switch (action)
{
case 'retry':
_resetBackoff();
_delayedConnect();
break;
case 'none':
_disconnect(true);
break;
default:
throw 'Unrecognized advice action ' + action;
}
}
else
{
_failHandshake(message);
}
}
function _handshakeFailure(message)
{
var version = '1.0';
var url = _cometd.getURL();
var oldTransport = _cometd.getTransport();
var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
if (!newTransport)
{
_notifyTransportFailure(oldTransport.getType(), null, message.failure);
_cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
_disconnect(true);
_failHandshake(message);
}
else
{
_cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());
_notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
_failHandshake(message);
_transport = newTransport;
}
}
function _failConnect(message)
{

 _notifyListeners('/meta/connect', message);
_notifyListeners('/meta/unsuccessful', message);

 
 
 var action = _isDisconnected() ? 'none' : _advice.reconnect;
switch (action)
{
case 'retry':
_delayedConnect();
_increaseBackoff();
break;
case 'handshake':

 
 _transports.reset();
_resetBackoff();
_delayedHandshake();
break;
case 'none':
_disconnect(true);
break;
default:
throw 'Unrecognized advice action' + action;
}
}
function _connectResponse(message)
{
_connected = message.successful;
if (_connected)
{
_notifyListeners('/meta/connect', message);

 
 
 
 var action = _isDisconnected() ? 'none' : _advice.reconnect;
switch (action)
{
case 'retry':
_resetBackoff();
_delayedConnect();
break;
case 'none':

 _disconnect(false);
break;
default:
throw 'Unrecognized advice action ' + action;
}
}
else
{
_failConnect(message);
}
}
function _connectFailure(message)
{
_connected = false;
_failConnect(message);
}
function _failDisconnect(message)
{
_disconnect(true);
_handleCallback(message);
_notifyListeners('/meta/disconnect', message);
_notifyListeners('/meta/unsuccessful', message);
}
function _disconnectResponse(message)
{
if (message.successful)
{

 _disconnect(false);
_handleCallback(message);
_notifyListeners('/meta/disconnect', message);
}
else
{
_failDisconnect(message);
}
}
function _disconnectFailure(message)
{
_failDisconnect(message);
}
function _failSubscribe(message)
{
var subscriptions = _listeners[message.subscription];
if (subscriptions)
{
for (var i = subscriptions.length - 1; i >= 0; --i)
{
var subscription = subscriptions[i];
if (subscription && !subscription.listener)
{
delete subscriptions[i];
_cometd._debug('Removed failed subscription', subscription);
break;
}
}
}
_handleCallback(message);
_notifyListeners('/meta/subscribe', message);
_notifyListeners('/meta/unsuccessful', message);
}
function _subscribeResponse(message)
{
if (message.successful)
{
_handleCallback(message);
_notifyListeners('/meta/subscribe', message);
}
else
{
_failSubscribe(message);
}
}
function _subscribeFailure(message)
{
_failSubscribe(message);
}
function _failUnsubscribe(message)
{
_handleCallback(message);
_notifyListeners('/meta/unsubscribe', message);
_notifyListeners('/meta/unsuccessful', message);
}
function _unsubscribeResponse(message)
{
if (message.successful)
{
_handleCallback(message);
_notifyListeners('/meta/unsubscribe', message);
}
else
{
_failUnsubscribe(message);
}
}
function _unsubscribeFailure(message)
{
_failUnsubscribe(message);
}
function _failMessage(message)
{
if (!_handleRemoteCall(message))
{
_handleCallback(message);
_notifyListeners('/meta/publish', message);
_notifyListeners('/meta/unsuccessful', message);
}
}
function _messageResponse(message)
{
if (message.data !== undefined)
{
if (!_handleRemoteCall(message))
{
_notifyListeners(message.channel, message);
}
}
else
{
if (message.successful === undefined)
{
_cometd._warn('Unknown Bayeux Message', message);
}
else
{
if (message.successful)
{
_handleCallback(message);
_notifyListeners('/meta/publish', message);
}
else
{
_failMessage(message);
}
}
}
}
function _messageFailure(failure)
{
_failMessage(failure);
}
function _receive(message)
{
message = _applyIncomingExtensions(message);
if (message === undefined || message === null)
{
return;
}
_updateAdvice(message.advice);
var channel = message.channel;
switch (channel)
{
case '/meta/handshake':
_handshakeResponse(message);
break;
case '/meta/connect':
_connectResponse(message);
break;
case '/meta/disconnect':
_disconnectResponse(message);
break;
case '/meta/subscribe':
_subscribeResponse(message);
break;
case '/meta/unsubscribe':
_unsubscribeResponse(message);
break;
default:
_messageResponse(message);
break;
}
}

this.receive = _receive;
_handleMessages = function(rcvdMessages)
{
_cometd._debug('Received', rcvdMessages);
for (var i = 0; i < rcvdMessages.length; ++i)
{
var message = rcvdMessages[i];
_receive(message);
}
};
_handleFailure = function(conduit, messages, failure)
{
_cometd._debug('handleFailure', conduit, messages, failure);
failure.transport = conduit;
for (var i = 0; i < messages.length; ++i)
{
var message = messages[i];
var failureMessage = {
id: message.id,
successful: false,
channel: message.channel,
failure: failure
};
failure.message = message;
switch (message.channel)
{
case '/meta/handshake':
_handshakeFailure(failureMessage);
break;
case '/meta/connect':
_connectFailure(failureMessage);
break;
case '/meta/disconnect':
_disconnectFailure(failureMessage);
break;
case '/meta/subscribe':
failureMessage.subscription = message.subscription;
_subscribeFailure(failureMessage);
break;
case '/meta/unsubscribe':
failureMessage.subscription = message.subscription;
_unsubscribeFailure(failureMessage);
break;
default:
_messageFailure(failureMessage);
break;
}
}
};
function _hasSubscriptions(channel)
{
var subscriptions = _listeners[channel];
if (subscriptions)
{
for (var i = 0; i < subscriptions.length; ++i)
{
if (subscriptions[i])
{
return true;
}
}
}
return false;
}
function _resolveScopedCallback(scope, callback)
{
var delegate = {
scope: scope,
method: callback
};
if (_isFunction(scope))
{
delegate.scope = undefined;
delegate.method = scope;
}
else
{
if (_isString(callback))
{
if (!scope)
{
throw 'Invalid scope ' + scope;
}
delegate.method = scope[callback];
if (!_isFunction(delegate.method))
{
throw 'Invalid callback ' + callback + ' for scope ' + scope;
}
}
else if (!_isFunction(callback))
{
throw 'Invalid callback ' + callback;
}
}
return delegate;
}
function _addListener(channel, scope, callback, isListener)
{

 

var delegate = _resolveScopedCallback(scope, callback);
_cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
var subscription = {
channel: channel,
scope: delegate.scope,
callback: delegate.method,
listener: isListener
};
var subscriptions = _listeners[channel];
if (!subscriptions)
{
subscriptions = [];
_listeners[channel] = subscriptions;
}

 
 
 
 
 subscription.id = subscriptions.push(subscription) - 1;
_cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);

 subscription[0] = channel;
subscription[1] = subscription.id;
return subscription;
}

 
 


this.registerTransport = function(type, transport, index)
{
var result = _transports.add(type, transport, index);
if (result)
{
this._debug('Registered transport', type);
if (_isFunction(transport.registered))
{
transport.registered(type, this);
}
}
return result;
};

this.getTransportTypes = function()
{
return _transports.getTransportTypes();
};

this.unregisterTransport = function(type)
{
var transport = _transports.remove(type);
if (transport !== null)
{
this._debug('Unregistered transport', type);
if (_isFunction(transport.unregistered))
{
transport.unregistered();
}
}
return transport;
};
this.unregisterTransports = function()
{
_transports.clear();
};
this.findTransport = function(name)
{
return _transports.find(name);
};

this.configure = function(configuration)
{
_configure.call(this, configuration);
};

this.init = function(configuration, handshakeProps)
{
this.configure(configuration);
this.handshake(handshakeProps);
};

this.handshake = function(handshakeProps, handshakeCallback)
{
_setStatus('disconnected');
_reestablish = false;
_handshake(handshakeProps, handshakeCallback);
};

this.disconnect = function(sync, disconnectProps, disconnectCallback)
{
if (_isDisconnected())
{
return;
}
if (typeof sync !== 'boolean')
{
disconnectCallback = disconnectProps;
disconnectProps = sync;
sync = false;
}
if (_isFunction(disconnectProps))
{
disconnectCallback = disconnectProps;
disconnectProps = undefined;
}
var bayeuxMessage = {
id: _nextMessageId(),
channel: '/meta/disconnect'
};

 var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);

 _cometd._putCallback(message.id, disconnectCallback);
_setStatus('disconnecting');
_send(sync === true, [message], false, 'disconnect');
};

this.startBatch = function()
{
_startBatch();
};

this.endBatch = function()
{
_endBatch();
};

this.batch = function(scope, callback)
{
var delegate = _resolveScopedCallback(scope, callback);
this.startBatch();
try
{
delegate.method.call(delegate.scope);
this.endBatch();
}
catch (x)
{
this._info('Exception during execution of batch', x);
this.endBatch();
throw x;
}
};

this.addListener = function(channel, scope, callback)
{
if (arguments.length < 2)
{
throw 'Illegal arguments number: required 2, got ' + arguments.length;
}
if (!_isString(channel))
{
throw 'Illegal argument type: channel must be a string';
}
return _addListener(channel, scope, callback, true);
};

this.removeListener = function(subscription)
{

 if (!subscription || !subscription.channel || !("id" in subscription))
{
throw 'Invalid argument: expected subscription, not ' + subscription;
}
_removeListener(subscription);
};

this.clearListeners = function()
{
_listeners = {};
};

this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback)
{
if (arguments.length < 2)
{
throw 'Illegal arguments number: required 2, got ' + arguments.length;
}
if (!_isString(channel))
{
throw 'Illegal argument type: channel must be a string';
}
if (_isDisconnected())
{
throw 'Illegal state: already disconnected';
}

 if (_isFunction(scope))
{
subscribeCallback = subscribeProps;
subscribeProps = callback;
callback = scope;
scope = undefined;
}
if (_isFunction(subscribeProps))
{
subscribeCallback = subscribeProps;
subscribeProps = undefined;
}

 var send = !_hasSubscriptions(channel);
var subscription = _addListener(channel, scope, callback, false);
if (send)
{

 
 
 var bayeuxMessage = {
id: _nextMessageId(),
channel: '/meta/subscribe',
subscription: channel
};

 var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);

 _cometd._putCallback(message.id, subscribeCallback);
_queueSend(message);
}
return subscription;
};

this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback)
{
if (arguments.length < 1)
{
throw 'Illegal arguments number: required 1, got ' + arguments.length;
}
if (_isDisconnected())
{
throw 'Illegal state: already disconnected';
}
if (_isFunction(unsubscribeProps))
{
unsubscribeCallback = unsubscribeProps;
unsubscribeProps = undefined;
}

 
 this.removeListener(subscription);
var channel = subscription.channel;

 if (!_hasSubscriptions(channel))
{
var bayeuxMessage = {
id: _nextMessageId(),
channel: '/meta/unsubscribe',
subscription: channel
};

 var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);

 _cometd._putCallback(message.id, unsubscribeCallback);
_queueSend(message);
}
};
this.resubscribe = function(subscription, subscribeProps)
{
_removeSubscription(subscription);
if (subscription)
{
return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
}
return undefined;
};

this.clearSubscriptions = function()
{
_clearSubscriptions();
};

this.publish = function(channel, content, publishProps, publishCallback)
{
if (arguments.length < 1)
{
throw 'Illegal arguments number: required 1, got ' + arguments.length;
}
if (!_isString(channel))
{
throw 'Illegal argument type: channel must be a string';
}
if (/^\/meta\//.test(channel))
{
throw 'Illegal argument: cannot publish to meta channels';
}
if (_isDisconnected())
{
throw 'Illegal state: already disconnected';
}
if (_isFunction(content))
{
publishCallback = content;
content = publishProps = {};
}
else if (_isFunction(publishProps))
{
publishCallback = publishProps;
publishProps = {};
}
var bayeuxMessage = {
id: _nextMessageId(),
channel: channel,
data: content
};

 var message = this._mixin(false, {}, publishProps, bayeuxMessage);

 _cometd._putCallback(message.id, publishCallback);
_queueSend(message);
};
this.remoteCall = function(target, content, timeout, callback)
{
if (arguments.length < 1)
{
throw 'Illegal arguments number: required 1, got ' + arguments.length;
}
if (!_isString(target))
{
throw 'Illegal argument type: target must be a string';
}
if (_isDisconnected())
{
throw 'Illegal state: already disconnected';
}
if (_isFunction(content))
{
callback = content;
content = {};
timeout = _config.maxNetworkDelay;
}
else if (_isFunction(timeout))
{
callback = timeout;
timeout = _config.maxNetworkDelay;
}
if (typeof timeout !== 'number')
{
throw 'Illegal argument type: timeout must be a number';
}
if (!target.match(/^\//))
{
target = '/' + target;
}
var channel = '/service' + target;
var bayeuxMessage = {
id: _nextMessageId(),
channel: channel,
data: content
};
var context = {
callback: callback
};
if (timeout > 0)
{
context.timeout = org.cometd.Utils.setTimeout(_cometd, function()
{
_cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');
_failMessage({
id: bayeuxMessage.id,
error: '406::timeout',
successful: false,
failure: {
message : bayeuxMessage,
reason: 'Remote Call Timeout'
}
});
}, timeout);
_cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');
}
_remoteCalls[bayeuxMessage.id] = context;
_queueSend(bayeuxMessage);
};

this.getStatus = function()
{
return _status;
};

this.isDisconnected = _isDisconnected;

this.setBackoffIncrement = function(period)
{
_config.backoffIncrement = period;
};

this.getBackoffIncrement = function()
{
return _config.backoffIncrement;
};

this.getBackoffPeriod = function()
{
return _backoff;
};

this.setLogLevel = function(level)
{
_config.logLevel = level;
};

this.registerExtension = function(name, extension)
{
if (arguments.length < 2)
{
throw 'Illegal arguments number: required 2, got ' + arguments.length;
}
if (!_isString(name))
{
throw 'Illegal argument type: extension name must be a string';
}
var existing = false;
for (var i = 0; i < _extensions.length; ++i)
{
var existingExtension = _extensions[i];
if (existingExtension.name === name)
{
existing = true;
break;
}
}
if (!existing)
{
_extensions.push({
name: name,
extension: extension
});
this._debug('Registered extension', name);

 if (_isFunction(extension.registered))
{
extension.registered(name, this);
}
return true;
}
else
{
this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
return false;
}
};

this.unregisterExtension = function(name)
{
if (!_isString(name))
{
throw 'Illegal argument type: extension name must be a string';
}
var unregistered = false;
for (var i = 0; i < _extensions.length; ++i)
{
var extension = _extensions[i];
if (extension.name === name)
{
_extensions.splice(i, 1);
unregistered = true;
this._debug('Unregistered extension', name);

 var ext = extension.extension;
if (_isFunction(ext.unregistered))
{
ext.unregistered();
}
break;
}
}
return unregistered;
};

this.getExtension = function(name)
{
for (var i = 0; i < _extensions.length; ++i)
{
var extension = _extensions[i];
if (extension.name === name)
{
return extension.extension;
}
}
return null;
};

this.getName = function()
{
return _name;
};

this.getClientId = function()
{
return _clientId;
};

this.getURL = function()
{
if (_transport && typeof _config.urls === 'object')
{
var url = _config.urls[_transport.getType()];
if (url)
{
return url;
}
}
return _config.url;
};
this.getTransport = function()
{
return _transport;
};
this.getConfiguration = function()
{
return this._mixin(true, {}, _config);
};
this.getAdvice = function()
{
return this._mixin(true, {}, _advice);
};

 org.cometd.WebSocket = window.WebSocket;
};

(function($)
{
function bind($, org_cometd)
{

 org_cometd.JSON.toJSON = JSON.stringify;
org_cometd.JSON.fromJSON = JSON.parse;
function _setHeaders(xhr, headers)
{
if (headers)
{
for (var headerName in headers)
{
if (headerName.toLowerCase() === 'content-type')
{
continue;
}
xhr.setRequestHeader(headerName, headers[headerName]);
}
}
}

 function LongPollingTransport()
{
var _super = new org_cometd.LongPollingTransport();
var that = org_cometd.Transport.derive(_super);
that.xhrSend = function(packet)
{
return $.ajax({
url: packet.url,
async: packet.sync !== true,
type: 'POST',
contentType: 'application/json;charset=UTF-8',
data: packet.body,
global: false,
xhrFields: {

 withCredentials: true
},
beforeSend: function(xhr)
{

 xhr.withCredentials = true;
_setHeaders(xhr, packet.headers);

 return true;
},
success: packet.onSuccess,
error: function(xhr, reason, exception)
{
packet.onError(reason, exception);
}
});
};
return that;
}
function CallbackPollingTransport()
{
var _super = new org_cometd.CallbackPollingTransport();
var that = org_cometd.Transport.derive(_super);
that.jsonpSend = function(packet)
{
$.ajax({
url: packet.url,
async: packet.sync !== true,
type: 'GET',
dataType: 'jsonp',
jsonp: 'jsonp',
data: {

 message: packet.body
},
beforeSend: function(xhr)
{
_setHeaders(xhr, packet.headers);

 return true;
},
success: packet.onSuccess,
error: function(xhr, reason, exception)
{
packet.onError(reason, exception);
}
});
};
return that;
}
$.CometD = function(name)
{
var cometd = new org_cometd.CometD(name);

 if (org_cometd.WebSocket)
{
cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
}
cometd.registerTransport('long-polling', new LongPollingTransport());
cometd.registerTransport('callback-polling', new CallbackPollingTransport());
return cometd;
};

 $.cometd = new $.CometD();
return $.cometd;
}
if (typeof define === 'function' && define.amd)
{
define(['jquery', 'org/cometd'], bind);
}
else
{
bind(jQuery, org.cometd);
}
})();

this.at = this.at || {};
at.molindo = this.at.molindo || {};
at.molindo.MessageReceiver = function(channelId) {
this._channelId = channelId;
this._publisher = null;
this.onMessageReceived = function(message) {
};
this.successfulSubscription = function(publisher) {
this._publisher = publisher;
this.onSuccessfulSubscription(publisher);
};
this.onSuccessfulSubscription = function(publisher) {
};
this.getChannelId = function() {
return this._channelId;
};
this.publish = function(channelId, message) {
if (this._publisher != null) {
this._publisher.publish(channelId, message);
}
};
};
at.molindo.MessageReceiver.derive = function(baseObject){
function F() {}
F.prototype = baseObject;
return new F();
};
at.molindo.MessagePublisher = function(cometd) {
this._cometd = cometd;
this.publish = function(channelId, message) {
this._cometd.publish(channelId, message);
}
}
at.molindo.ConnectionCallbackHandler = function(messageReceiverArray) {
this._subscriberMap = initMap(messageReceiverArray);
function initMap(arr) {
var map = new Array();
for (var i = 0; i < arr.length; i++) {
var mr = arr[i];
var existing = map[mr.getChannelId()];
if (existing == null) {
existing = new Array();
map[mr.getChannelId()] = existing;
}
existing.push(mr);
}
return map;
}
this.onConnectionEstablished = function() {
};
this.onConnectionBroken = function() {
};
this.onConnectionClosed = function() {
};
this.onHandshake = function(handshake) {
};
this.getSubscriberMap = function() {
return this._subscriberMap;
}
};
at.molindo.ConnectionCallbackHandler.derive = function(baseObject){
function F() {}
F.prototype = baseObject;
return new F();
};
(function($)
{
var cometd = $.cometd;
at.molindo.CometdConnection = function(callbackHandler, logLevel)
{
var _subscriberMap = callbackHandler.getSubscriberMap();
function _connectionEstablished() {
callbackHandler.onConnectionEstablished();
_refresh();
}
function _connectionBroken() {
callbackHandler.onConnectionBroken();
}
function _connectionClosed() {
callbackHandler.onConnectionClosed();
}

 var _connected = false;
function _metaConnect(message)
{
if (cometd.isDisconnected()) {
_connected = false;
_connectionClosed();
return;
}
var wasConnected = _connected;
_connected = message.successful === true;
if (!wasConnected && _connected) {
_connectionEstablished();
}
else if (wasConnected && !_connected) {
_connectionBroken();
}
}

 
 function _metaHandshake(handshake) {
callbackHandler.onHandshake(handshake);
}

function _metaSubscribe(message) {
if (message.successful === true) {
var channelId = message.subscription;
_onSuccessfulSubscription(channelId);
}
}
var _subscription;
var _subscriptions = new Array();

 function _refresh() {
_appUnsubscribe();
_appSubscribe();
}
function _appUnsubscribe() {
if (_subscriptions) {
for (var channelId in _subscriptions) {
removeSubscription(channelId);
}
_subscriptions = new Array();
}
}
function _appSubscribe() {
var map = _subscriberMap;
for (var channelId in map) {

 if (map.hasOwnProperty(channelId)) {
var subscription = cometd.subscribe(channelId, function(msg) {
_onMessage(msg.channel, msg);
});
_subscriptions[channelId] = subscription;
}
}
}
function _onMessage(channelId, msg) {
var messageReceiverArray = _subscriberMap[channelId];
for (var i = 0; i < messageReceiverArray.length; i++) {
var messageReceiver = messageReceiverArray[i];
messageReceiver.onMessageReceived(msg);
}
}
function _onSuccessfulSubscription(channelId) {
var messageReceiverArray = _subscriberMap[channelId];
for (var i = 0; i < messageReceiverArray.length; i++) {
var messageReceiver = messageReceiverArray[i];
messageReceiver.successfulSubscription(new at.molindo.MessagePublisher(cometd));
}
}
function _addSubscription(messageReceiver) {
var channelId = messageReceiver.getChannelId();
var existingArr = _subscriberMap[channelId];
if (existingArr == null) {
existingArr = new Array();
_subscriberMap[channelId] = existingArr;
}
existingArr.push(messageReceiver);
if (!_subscriptions[channelId]) {
_subscriptions[channelId] = cometd.subscribe(channelId, function(msg) {
_onMessage(channelId, msg);
});
}
}
function removeSubscription(channelId) {
if (_subscriptions.hasOwnProperty(channelId)) {
cometd.unsubscribe(_subscriptions[channelId]);
_subscriptions[channelId] = null;
}
}
this.connect = function() {
var cometURL = location.protocol + "//" + location.host + "/cometd";
cometd.configure({
url: cometURL,
logLevel: logLevel
});
cometd.addListener('/meta/handshake', _metaHandshake);
cometd.addListener('/meta/connect', _metaConnect);
cometd.addListener('/meta/subscribe', _metaSubscribe);
cometd.handshake();
}
};

 $(window).unload(function() {
cometd.disconnect(true);
});
})(jQuery);


(function(b){b.support.touch="ontouchend" in document;if(!b.support.touch){return;}var c=b.ui.mouse.prototype,e=c._mouseInit,a;function d(g,h){if(g.originalEvent.touches.length>1){return;}g.preventDefault();var i=g.originalEvent.changedTouches[0],f=document.createEvent("MouseEvents");f.initMouseEvent(h,true,true,window,1,i.screenX,i.screenY,i.clientX,i.clientY,false,false,false,false,0,null);g.target.dispatchEvent(f);}c._touchStart=function(g){var f=this;if(a||!f._mouseCapture(g.originalEvent.changedTouches[0])){return;}a=true;f._touchMoved=false;d(g,"mouseover");d(g,"mousemove");d(g,"mousedown");};c._touchMove=function(f){if(!a){return;}this._touchMoved=true;d(f,"mousemove");};c._touchEnd=function(f){if(!a){return;}d(f,"mouseup");d(f,"mouseout");if(!this._touchMoved){d(f,"click");}a=false;};c._mouseInit=function(){var f=this;f.element.bind("touchstart",b.proxy(f,"_touchStart")).bind("touchmove",b.proxy(f,"_touchMove")).bind("touchend",b.proxy(f,"_touchEnd"));e.call(f);};})(jQuery);


(function (factory) {
if (typeof define === 'function' && define.amd) {

 define(['jquery'], factory);
} else {

 factory(jQuery);
}
}(function ($) {
$.timeago = function(timestamp) {
if (timestamp instanceof Date) {
return inWords(timestamp);
} else if (typeof timestamp === "string") {
return inWords($.timeago.parse(timestamp));
} else if (typeof timestamp === "number") {
return inWords(new Date(timestamp));
} else {
return inWords($.timeago.datetime(timestamp));
}
};
var $t = $.timeago;
$.extend($.timeago, {
settings: {
refreshMillis: 60000,
allowFuture: false,
localeTitle: false,
format: function(date) { return date.toLocaleString() },
formatTitle: function(date) { return this.format(date) },
cutoff: 0,
strings: {
prefixAgo: null,
prefixFromNow: null,
suffixAgo: "ago",
suffixFromNow: "from now",
seconds: "less than a minute",
minute: "about a minute",
minutes: "%d minutes",
hour: "about an hour",
hours: "about %d hours",
day: "a day",
days: "%d days",
month: "about a month",
months: "%d months",
year: "about a year",
years: "%d years",
wordSeparator: " ",
numbers: []
}
},
inWords: function(distanceMillis) {
var $l = this.settings.strings;
var prefix = $l.prefixAgo;
var suffix = $l.suffixAgo;
if (this.settings.allowFuture) {
if (distanceMillis < 0) {
prefix = $l.prefixFromNow;
suffix = $l.suffixFromNow;
}
}
var seconds = Math.abs(distanceMillis) / 1000;
var minutes = seconds / 60;
var hours = minutes / 60;
var days = hours / 24;
var years = days / 365;
function substitute(stringOrFunction, number) {
var string = $.isFunction(stringOrFunction) ? stringOrFunction(number, distanceMillis) : stringOrFunction;
var value = ($l.numbers && $l.numbers[number]) || number;
return string.replace(/%d/i, value);
}
var words = seconds < 45 && substitute($l.seconds, Math.round(seconds)) ||
seconds < 90 && substitute($l.minute, 1) ||
minutes < 45 && substitute($l.minutes, Math.round(minutes)) ||
minutes < 90 && substitute($l.hour, 1) ||
hours < 24 && substitute($l.hours, Math.round(hours)) ||
hours < 42 && substitute($l.day, 1) ||
days < 30 && substitute($l.days, Math.round(days)) ||
days < 45 && substitute($l.month, 1) ||
days < 365 && substitute($l.months, Math.round(days / 30)) ||
years < 1.5 && substitute($l.year, 1) ||
substitute($l.years, Math.round(years));
var separator = $l.wordSeparator || "";
if ($l.wordSeparator === undefined) { separator = " "; }
return $.trim([prefix, words, suffix].join(separator));
},
parse: function(iso8601) {
var s = $.trim(iso8601);
s = s.replace(/\.\d+/,""); 
 s = s.replace(/-/,"/").replace(/-/,"/");
s = s.replace(/T/," ").replace(/Z/," UTC");
s = s.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2"); 
 return new Date(s);
},
datetime: function(elem) {
var iso8601 = $t.isTime(elem) ? $(elem).attr("datetime") : $(elem).attr("data-isotime");
return $t.parse(iso8601);
},
isTime: function(elem) {

 return $(elem).get(0).tagName.toLowerCase() === "time"; 
 }
});

 
 
 var functions = {
init: function(){
var refresh_el = $.proxy(refresh, this);
refresh_el();
var $s = $t.settings;
if ($s.refreshMillis > 0) {
setInterval(refresh_el, $s.refreshMillis);
}
},
update: function(time){
$(this).data('timeago', { datetime: $t.parse(time) });
refresh.apply(this);
}
};
$.fn.timeago = function(action, options) {
var fn = action ? functions[action] : functions.init;
if(!fn){
throw new Error("Unknown function name '"+ action +"' for timeago");
}

 this.each(function(){
fn.call(this, options);
});
return this;
};
function refresh() {
var data = prepareData(this);
var $s = $t.settings;
if (!isNaN(data.datetime)) {
if ( $s.cutoff == 0 || distance(data.datetime) < $s.cutoff) {
$(this).text(inWords(data.datetime));
} else {
$(this).text($s.format(data.datetime));
}
}
return this;
}
function prepareData(element) {
element = $(element);
if (!element.data("timeago")) {
element.data("timeago", { datetime: $t.datetime(element) });
var text = $.trim(element.text());
if ($t.settings.localeTitle) {
element.attr("title", $t.settings.formatTitle(element.data('timeago').datetime));
} else if (text.length > 0 && !($t.isTime(element) && element.attr("title"))) {
element.attr("title", text);
}
}
return element.data("timeago");
}
function inWords(date) {
return $t.inWords(distance(date));
}
function distance(date) {
return (new Date().getTime() - date.getTime());
}

 document.createElement("abbr");
document.createElement("time");
}));



;(function($, undefined){

var ls = (typeof window.localStorage === 'undefined') ? undefined : window.localStorage;
var supported;
if (typeof ls == 'undefined' || typeof window.JSON == 'undefined'){
supported = false;
} else {
supported = true;
}

$.totalStorage = function(key, value, options){
return $.totalStorage.impl.init(key, value);
};
$.totalStorage.setItem = function(key, value){
return $.totalStorage.impl.setItem(key, value);
};
$.totalStorage.getItem = function(key){
return $.totalStorage.impl.getItem(key);
};
$.totalStorage.getAll = function(){
return $.totalStorage.impl.getAll();
};
$.totalStorage.deleteItem = function(key){
return $.totalStorage.impl.deleteItem(key);
};

$.totalStorage.impl = {
init: function(key, value){
if (typeof value != 'undefined') {
return this.setItem(key, value);
} else {
return this.getItem(key);
}
},
setItem: function(key, value){
if (!supported){
try {
$.cookie(key, value);
return value;
} catch(e){
console.log('Local Storage not supported by this browser. Install the cookie plugin on your site to take advantage of the same functionality. You can get it at https://github.com/carhartl/jquery-cookie');
}
}
var saver = JSON.stringify(value);
ls.setItem(key, saver);
return this.parseResult(saver);
},
getItem: function(key){
if (!supported){
try {
return this.parseResult($.cookie(key));
} catch(e){
return null;
}
}
var item = ls.getItem(key);
return this.parseResult(item);
},
deleteItem: function(key){
if (!supported){
try {
$.cookie(key, null);
return true;
} catch(e){
return false;
}
}
ls.removeItem(key);
return true;
},
getAll: function(){
var items = [];
if (!supported){
try {
var pairs = document.cookie.split(";");
for (var i = 0; i<pairs.length; i++){
var pair = pairs[i].split('=');
var key = pair[0];
items.push({key:key, value:this.parseResult($.cookie(key))});
}
} catch(e){
return null;
}
} else {
for (var j in ls){
if (j.length){
items.push({key:j, value:this.parseResult(ls.getItem(j))});
}
}
}
return items;
},
parseResult: function(res){
var ret;
try {
ret = JSON.parse(res);
if (typeof ret == 'undefined'){
ret = res;
}
if (ret == 'true'){
ret = true;
}
if (ret == 'false'){
ret = false;
}
if (parseFloat(ret) == ret && typeof ret != "object"){
ret = parseFloat(ret);
}
} catch(e){
ret = res;
}
return ret;
}
};
})(jQuery);


(function() {
var $, win;
$ = this.jQuery || window.jQuery;
win = $(window);
$.fn.stick_in_parent = function(opts) {
var doc, elm, enable_bottoming, inner_scrolling, manual_spacer, offset_top, outer_width, parent_selector, recalc_every, sticky_class, _fn, _i, _len;
if (opts == null) {
opts = {};
}
sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
if (offset_top == null) {
offset_top = 0;
}
if (parent_selector == null) {
parent_selector = void 0;
}
if (inner_scrolling == null) {
inner_scrolling = true;
}
if (sticky_class == null) {
sticky_class = "is_stuck";
}
doc = $(document);
if (enable_bottoming == null) {
enable_bottoming = true;
}
outer_width = function(el) {
var computed, w, _el;
if (window.getComputedStyle) {
_el = el[0];
computed = window.getComputedStyle(el[0]);
w = parseFloat(computed.getPropertyValue("width")) + parseFloat(computed.getPropertyValue("margin-left")) + parseFloat(computed.getPropertyValue("margin-right"));
if (computed.getPropertyValue("box-sizing") !== "border-box") {
w += parseFloat(computed.getPropertyValue("border-left-width")) + parseFloat(computed.getPropertyValue("border-right-width")) + parseFloat(computed.getPropertyValue("padding-left")) + parseFloat(computed.getPropertyValue("padding-right"));
}
return w;
} else {
return el.outerWidth(true);
}
};
_fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
if (elm.data("sticky_kit")) {
return;
}
elm.data("sticky_kit", true);
last_scroll_height = doc.height();
parent = elm.parent();
if (parent_selector != null) {
parent = parent.closest(parent_selector);
}
if (!parent.length) {
throw "failed to find stick parent";
}
fixed = false;
bottomed = false;
spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
if (spacer) {
spacer.css('position', elm.css('position'));
}
recalc = function() {
var border_top, padding_top, restore;
if (detached) {
return;
}
last_scroll_height = doc.height();
border_top = parseInt(parent.css("border-top-width"), 10);
padding_top = parseInt(parent.css("padding-top"), 10);
padding_bottom = parseInt(parent.css("padding-bottom"), 10);
parent_top = parent.offset().top + border_top + padding_top;
parent_height = parent.height();
if (fixed) {
fixed = false;
bottomed = false;
if (manual_spacer == null) {
elm.insertAfter(spacer);
spacer.detach();
}
elm.css({
position: "",
top: "",
width: "",
bottom: ""
}).removeClass(sticky_class);
restore = true;
}
top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
height = elm.outerHeight(true);
el_float = elm.css("float");
if (spacer) {
spacer.css({
width: outer_width(elm),
height: height,
display: elm.css("display"),
"vertical-align": elm.css("vertical-align"),
"float": el_float
});
}
if (restore) {
return tick();
}
};
recalc();
if (height === parent_height) {
return;
}
last_pos = void 0;
offset = offset_top;
recalc_counter = recalc_every;
tick = function() {
var css, delta, recalced, scroll, will_bottom, win_height;
if (detached) {
return;
}
recalced = false;
if (recalc_counter != null) {
recalc_counter -= 1;
if (recalc_counter <= 0) {
recalc_counter = recalc_every;
recalc();
recalced = true;
}
}
if (!recalced && doc.height() !== last_scroll_height) {
recalc();
recalced = true;
}
scroll = win.scrollTop();
if (last_pos != null) {
delta = scroll - last_pos;
}
last_pos = scroll;
if (fixed) {
if (enable_bottoming) {
will_bottom = scroll + height + offset > parent_height + parent_top;
if (bottomed && !will_bottom) {
bottomed = false;
elm.css({
position: "fixed",
bottom: "",
top: offset
}).trigger("sticky_kit:unbottom");
}
}
if (scroll < top) {
fixed = false;
offset = offset_top;
if (manual_spacer == null) {
if (el_float === "left" || el_float === "right") {
elm.insertAfter(spacer);
}
spacer.detach();
}
css = {
position: "",
width: "",
top: ""
};
elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
}
if (inner_scrolling) {
win_height = win.height();
if (height + offset_top > win_height) {
if (!bottomed) {
offset -= delta;
offset = Math.max(win_height - height, offset);
offset = Math.min(offset_top, offset);
if (fixed) {
elm.css({
top: offset + "px"
});
}
}
}
}
} else {
if (scroll > top) {
fixed = true;
css = {
position: "fixed",
top: offset
};
css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
elm.css(css).addClass(sticky_class);
if (manual_spacer == null) {
elm.after(spacer);
if (el_float === "left" || el_float === "right") {
spacer.append(elm);
}
}
elm.trigger("sticky_kit:stick");
}
}
if (fixed && enable_bottoming) {
if (will_bottom == null) {
will_bottom = scroll + height + offset > parent_height + parent_top;
}
if (!bottomed && will_bottom) {
bottomed = true;
if (parent.css("position") === "static") {
parent.css({
position: "relative"
});
}
return elm.css({
position: "absolute",
bottom: padding_bottom,
top: "auto"
}).trigger("sticky_kit:bottom");
}
}
};
recalc_and_tick = function() {
recalc();
return tick();
};
detach = function() {
detached = true;
win.off("touchmove", tick);
win.off("scroll", tick);
win.off("resize", recalc_and_tick);
$(document.body).off("sticky_kit:recalc", recalc_and_tick);
elm.off("sticky_kit:detach", detach);
elm.removeData("sticky_kit");
elm.css({
position: "",
bottom: "",
top: "",
width: ""
});
parent.position("position", "");
if (fixed) {
if (manual_spacer == null) {
if (el_float === "left" || el_float === "right") {
elm.insertAfter(spacer);
}
spacer.remove();
}
return elm.removeClass(sticky_class);
}
};
win.on("touchmove", tick);
win.on("scroll", tick);
win.on("resize", recalc_and_tick);
$(document.body).on("sticky_kit:recalc", recalc_and_tick);
elm.on("sticky_kit:detach", detach);
return setTimeout(tick, 0);
};
for (_i = 0, _len = this.length; _i < _len; _i++) {
elm = this[_i];
_fn($(elm));
}
return this;
};
}).call(this);
(function($){

var $w = $(window);
$.fn.visible = function(partial,hidden,direction){
if (this.length < 1)
return;
var $t = this.length > 1 ? this.eq(0) : this,
t = $t.get(0),
vpWidth = $w.width(),
vpHeight = $w.height(),
direction = (direction) ? direction : 'both',
clientSize = hidden === true ? t.offsetWidth * t.offsetHeight : true;
if (typeof t.getBoundingClientRect === 'function'){

 var rec = t.getBoundingClientRect(),
tViz = rec.top >= 0 && rec.top < vpHeight,
bViz = rec.bottom > 0 && rec.bottom <= vpHeight,
lViz = rec.left >= 0 && rec.left < vpWidth,
rViz = rec.right > 0 && rec.right <= vpWidth,
vVisible = partial ? tViz || bViz : tViz && bViz,
hVisible = partial ? lViz || rViz : lViz && rViz;
if(direction === 'both')
return clientSize && vVisible && hVisible;
else if(direction === 'vertical')
return clientSize && vVisible;
else if(direction === 'horizontal')
return clientSize && hVisible;
} else {
var viewTop = $w.scrollTop(),
viewBottom = viewTop + vpHeight,
viewLeft = $w.scrollLeft(),
viewRight = viewLeft + vpWidth,
offset = $t.offset(),
_top = offset.top,
_bottom = _top + $t.height(),
_left = offset.left,
_right = _left + $t.width(),
compareTop = partial === true ? _bottom : _top,
compareBottom = partial === true ? _top : _bottom,
compareLeft = partial === true ? _right : _left,
compareRight = partial === true ? _left : _right;
if(direction === 'both')
return !!clientSize && ((compareBottom <= viewBottom) && (compareTop >= viewTop)) && ((compareRight <= viewRight) && (compareLeft >= viewLeft));
else if(direction === 'vertical')
return !!clientSize && ((compareBottom <= viewBottom) && (compareTop >= viewTop));
else if(direction === 'horizontal')
return !!clientSize && ((compareRight <= viewRight) && (compareLeft >= viewLeft));
}
};
})(jQuery);